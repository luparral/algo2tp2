\subsection{Interfaz}
%%###no tenemos no parametros formales?

  %%\InterfazFuncion{AgregarAdelante}{\Inout{l}{lista($\alpha$)}, \In{a}{$\alpha$}}{itLista($\alpha$}

%%Parámetros formales
  \subsubsection{Par\'ametros formales}
   \parbox{1.7cm}{\textbf{g\'eneros}} wolfie\\
    %%\parbox[t]{1.7cm}{\textbf{funci\'on}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
     %%\InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
     %%{$res \igobs a$}
     %%[$\Theta(copy(a))$]
     %%[funci\'on de copia de $\alpha$ s]
    %%}

  \textbf{se explica con}: \tadNombre{Wolfie}.

    %%\textbf{g\'eneros}: \TipoVariable{lista$(\alpha)$}, \TipoVariable{itLista($\alpha$)}.

%%Operaciones básicas
  \subsubsection{Operaciones b\'asicas de wolfie}
 %%clientes
  \InterfazFuncion{Clientes}{\In{w}{wolfie}}{itConjEstNat(cliente)}
  {$res$ \igobs crearItUni(clientes($w$))}
  [$O(1)$]
  [Devuelve un iterador a los clientes de un wolfie.]\\\\
 %%titulos
  \InterfazFuncion{T\'itulos}{\In{w}{wolfie}}{itUni(t\'itulo)}
  {$res$ \igobs crearItUni(t\'itulos($w$))}%
  [$O(1)$]
  [Devuelve un iterador a los t\'itulos de un wolfie.]\\\\
%%promesasDe
  \InterfazFuncion{PromesasDe}{\In{c}{cliente}, \In{w}{wolfie}}{itConj(promesa)}
  [$c \in$ clientes($w$)]
  {$res$ \igobs crearItUni(promesasDe($c$, $w$))}%
  [$O(T \cdotp C \cdotp |max\_nt|)$]
  [Devuelve un iterador a las promesas de un wolfie]\\\\
  %%accionesPorCliente
  \InterfazFuncion{AccionesPorCliente}{\In{c}{cliente}, \In{nt}{nombre}, \In{w}{wolfie}}{$nat$}%
  [$c \in$ clientes($w$) $\land$ ($\exists$ $t$:t\'itulo) ($t \in$ t\'itulos($w$) $\land$ nombre($t$) = $nt$)]
  %%###ojo con nombreTitulo
  {$res$ \igobs accionesPorCliente($c$, $nt$, $w$)}%
  [$O(log(C)+|nt|)$]
  [Devuelve la cantidad de acciones que un cliente posee de un determinado t\'itulo.]\\\\
%%inaugurarWolfie
  \InterfazFuncion{InaugurarWolfie}{\In{cs}{conj(cliente)}}{wolfie}%%&&& conj(cliente)? No rompe nada usar un conjunto aca? ---lo implementamos como vector
  [$\neg\emptyset$?($cs$)]
  {$res$ \igobs inaugurarWolfie($cs$)}
  [$O(\#(cs)^2)$]
  [Crea un nuevo wolfie a partir de un conjunto de clientes.]\\\\  %%&&& la complejidad habia quedado n log n si usamos merge sort
%%agregarTitulo
  \InterfazFuncion{AgregarT\'itulo}{\In{t}{t\'itulo}, \Inout{w}{wolfie}}{}%
  [$w_{0}$ \igobs $w$ $\land$ ($\forall$ $t2$:t\'itulo) ($t2$ $\in$ t\'itulos($w$) $\Rightarrow$ nombre($t$) $\neq$ nombre($t2$)]
  {$w$ \igobs agregarT\'itulo($t$, $w_{0}$}%
  [$O(|nombre(t)|+C)$]\\\\
%%actualizarCotizacion
  \InterfazFuncion{ActualizarCotizaci\'on}{\In{nt}{nombre}, \In{cot}{nat}, \Inout{w}{wolfie}}{}%
  %%### ojo con NombreTítulo
  [$w_{0}$ \igobs $w$ $\land$ ($\exists$ $t$:t\'itulo) ($t$ $\in$ t\'itulos($w$) $\land$ nombre($t$) = $nt$)]
  {$w$ $\igobs$ actualizarCotizaci\'on($nt$, $cot$, $w_{0}$)}%
  [$O(C \cdotp |nt|+C \cdotp log(C))$]
  [Cambia la cotizaci\'on de un determinado t\'itulo. Esta operaci\'on genera que se desencadene el cumplimiento de promesas (seg\'un corresponda): primero de venta y luego, de compra, seg\'un el orden descendente de cantidad de acciones por t\'itulo de cada cliente.]\\\\
%%agregarPromesa
  \InterfazFuncion{AgregarPromesa}{\In{c}{cliente}, \In{p}{promesa}, \Inout{w}{wolfie}}{}%
  [$w_{0}$ \igobs $w$ $\land$ ($\exists$$t$: t\'itulo) ($t$ $\in$ t\'itulos($w$) $\land$ nombre($t$) = t\'itulo($p$)) $\land$ $c$ $\in$ clientes($w$) \yluego ($\forall$$p2$: promesa) ($p2$ $\in$ promesasDe($c$, $w$) $\Rightarrow$ (t\'itulo($p$) $\neq$ t\'itulo($p2$) $\lor$ tipo($p$) $\neq$ tipo($p2$)) ) $\land$ (tipo($p$) = vender $\Rightarrow$ accionesPorCliente($c$, t\'itulo($p$), $w$) $\geq$ cantidad($p$)))]
  {$w$ \igobs agregarPromesa($c$, $p$, $w_{0}$)}%
  [$O(|t$\'i$tulo(p)| + log(C))$]
  [Agrega una nueva promesa.]\\\\
%%enAlza
  \InterfazFuncion{EnAlza}{\In{nt}{nombreT\'itulo}, \In{w}{wolfie}}{bool}%%&&& aca estaba mal la aridad
  [($\exists$$t$: t\'itulo) ($t$ $\in$ t\'itulos($w$) $\land$ nombre($t$) = nt)]
  {$res$ \igobs enAlza($nt$, $w$)}%
  [$O(|nt|)$]
  [Dado un t\'itulo, informa si est\'a o no en alza.]\\\\
  %%### ojo con NombreTítulo
  
   \subsubsection{Operaciones b\'asicas de itT\'itulos}
   
  \InterfazFuncion{CrearIt}{\In{w}{wolfie}}{itT\'itulo}%%&&& aca estaba mal la aridad
  {$res$ \igobs crearItUni(titulos(w))}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
  [$O(1)$]
  [Devuelve un iterador unidireccional a los t\'itulos de wolfie.]\\\\
  
  \InterfazFuncion{Actual}{\In{i}{itT\'itulo}}{t\'itulo}%%&&& aca estaba mal la aridad
  {$res$ \igobs actual(i)}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
  [$O(|titulo(actual(i))|)$]
  [Devuelve el t\'itulo actual.]\\\\
  
  \InterfazFuncion{Pr\'oximo}{\Inout{i}{itT\'itulo}}%%&&& aca estaba mal la aridad
  [HayPr\'oximo(i) $\land$ $i_{0}=i$]
  {$i$ \igobs avanzar($i_{0}$)}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
  [$O(1)$]
  [Avanza el iterador.]\\\\
     
  \InterfazFuncion{HayPr\'oximo}{\Inout{i}{itT\'itulo}}{bool}%%&&& aca estaba mal la aridad
  {$res$ \igobs hayMas(i)}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
  [$O(1)$]
  [Pregunta si hay m\'as elementos para iterar.]\\\\
  
%%&&& las complejidades van con O grande, no con tita

\subsection{Representaci\'on}
\subsubsection{Representaci\'on de wolfie}
%------------------------estr----------------------------
\begin{Estructura}{wolfie}[estr]
    \begin{Tupla}[estr]
      \tupItem{t\'itulos}{diccString(infoT\'itulo),}%
      	
      \tupItem{clientes}{conjEstNat(cliente)}
      
      \tupItem{\'ultimoLlamado}{<$cliente$: cliente, $promesas$:conj(promesa), $fueUltimo$: bool>)}%
    \end{Tupla}

    \begin{Tupla}[infoT\'itulo]
    	\tupItem{arrayClientes}{array\_dimensionable(tuplaPorCliente),}
    	\tupItem{t\'itulo}{t\'itulo,}
    	\tupItem{accDisponibles}{nat}
    \end{Tupla}
    
    \begin{Tupla}[tuplaPorCliente]
    	\tupItem{cliente}{cliente,}
    	\tupItem{cantAcc}{nat,}
    	\tupItem{promCompra}{*promesa,}
    	\tupItem{promVenta}{*promesa}
    \end{Tupla}
    \indent\indent Con un orden definido por $a$<$b$ $\Leftrightarrow$ $a.cliente$ < $b.cliente$
    
    \begin{Tupla}[tuplaPorCantAcc]
    	\tupItem{cliente}{cliente,}
    	\tupItem{cantAcc}{nat,}
    	\tupItem{promCompra}{*promesa,}
    	\tupItem{promVenta}{*promesa}
    \end{Tupla}
    \indent\indent Con un orden definido por $a$<$b$ $\Leftrightarrow$ $a.cantAcc$ > $b.cantAcc$ %%%%%manganeta

\end{Estructura}
 %----------------------------------------------------Rep------------------------------------------
\subsubsection{Invariante de representaci\'on}
 \renewcommand{\labelenumi}{(\Roman{enumi})}
 \begin{enumerate}
 	\item Los clientes de $clientes$ son los mismos que hay dentro de $titulos$.
 	\item Las promesas de compra son de su t\'itulo y cliente y no cumplen los requisitos para ejecutarse.
 	\item Las promesas de venta son de su t\'itulo y cliente y no cumplen los requisitos para ejecutarse.
 	\item Las acciones disponibles de cada t\'itulo son el m\'aximo de acciones de ese t\'itulo menos la suma de las acciones de ese titulo que tengan los clientes, y son mayores o iguales a 0.
 	\item El $cliente$ de $\acute{u}ltimoLlamado$ pertenece a $clientes$.
 	\item En $\acute{u}ltimoLlamado$, si $fue\acute{U}ltimo$ es true, las promesas de $promesas$ son todas las promesas que tiene $cliente$.
 	\item Los clientes est\'an ordenados en $arrayClientes$ de $e.titulos$.
 	\item Los t\'itulos en infoT\'itulo tienen el mismo nombre que la clave que lleva a ellos.
  \end{enumerate}
  
  \Rep[estr][e]{\\
 	(I)\begin{minipage}[t]{\linewidth-\parindent-1.3cm}
  		($\forall$ $c$: cliente) {\Large(}pertenece?($c$, $e.clientes$) $\Leftrightarrow$ ($\exists$ $t$: t\'itulo) {\large(}def?($t$, $e.titulos$) \yluego est\'aCliente?($c$, obtener($t$, $e.titulos$).$arrayClientes$){\large)}{\Large)} \yluego
  	\end{minipage}\vspace{3mm}

  	(II)\begin{minipage}[t]{\linewidth-\parindent-1.3cm}
  		($\forall$ $p$: $*$promesa, $t$: nombre, $c$: cliente) {\large(}(p $\neq$ NULL $\land$ def?($t$, $e.titulos$) \yluego  est\'aCliente?($c$, obtener($t$, $e.titulos$).$arrayClientes$) \yluego buscarCliente($c$, obtener($t$, $e.titulos$).$arrayClientes$).$promCompra$=$p$) \impluego  t\'itulo($*p$)=$t$ $\land$ tipo($*p$)=compra $\land$ (l\'imite($*p$)>cotizaci\'on(obtener($t$, $e.titulos$).$titulo$) $\lor$ cantidad($*p$)>obtener($t$, $e.titulos$).$accDisponibles$){\large)} $\land$
  	\end{minipage}\vspace{3mm}
  	
  	(III)\begin{minipage}[t]{\linewidth-\parindent-1.3cm}
  		($\forall$ $p$: $*$promesa, $t$: nombre, $c$: cliente) {\large(}(p $\neq$ NULL $\land$ def?($t$, $e.titulos$) \yluego  est\'aCliente?($c$, obtener($t$, $e.titulos$).$arrayClientes$) \yluego buscarCliente($c$, obtener($t$, $e.titulos$).$arrayClientes$).$promVenta$=$p$) \impluego (t\'itulo($*p$)=$t$ $\land$ tipo($*p$)=venta $\land$ l\'imite($*p$) < cotizaci\'on(obtener($t$, $e.titulos$).$titulo$)){\large)} $\land$
  	\end{minipage}\vspace{3mm}
  	
  	(IV)\begin{minipage}[t]{\linewidth-\parindent-2cm}
		($\forall$ $nt$: nombreT) (def?($nt$, $e.titulos$) \impluego (obtener($nt$, $e.titulos$).$accDisponibles$ = m\'aximo(obtener($nt$, $e.titulos$).$titulo$) - sumaAccClientes(obtener($nt$, $e.titulos$).$arrayClientes$, 0) $\land$ obtener($nt$, $e.titulos$).$accDisponibles$ $\geq$ 0)) $\land$
  	\end{minipage}\vspace{3mm}
  	
  	(V)\begin{minipage}[t]{\linewidth-\parindent-2cm}
		(pertenece?($e.\acute{u}ltimoLlamado.cliente$, $e.clientes$)) \yluego
  	\end{minipage}\vspace{3mm}
  	
	(VI)\begin{minipage}[t]{\linewidth-\parindent-2cm}
		($e.\acute{u}ltimoLlamado.fue\acute{U}ltimo$ $\Rightarrow$ ($\forall$ $p$: promesa) {\Large(}pertenece?($p$, $e.\acute{u}ltimoLlamado.promesas$) $\Leftrightarrow$ {\large(}def?(t\'itulo($p$), $e.titulos$) \yluego \\ {\IF tipo($p$)=compra THEN buscarCliente($e.\acute{u}ltimoLlamado.cliente$, obtener(t\'itulo($p$), $e.titulos$).$arrayClientes$).promCompra = $p$ ELSE buscarCliente($e.\acute{u}ltimoLlamado.cliente$, obtener(t\'itulo($p$), $e.titulos$).$arrayClientes$).promVenta = $p$ FI}{\large)}{\Large)}
  	\end{minipage}\vspace{3mm}
  	
  	(VII)\begin{minipage}[t]{\linewidth-\parindent-2cm}
		($\forall$ $t$: nombre) def?($t, e.titulos$) \impluego {\large(}($\forall$ $i$:nat) i<longitud(buscar($t, e.titulos$).$arrayClientes$)-1 $\Rightarrow$ (buscar($t, e.titulos$).$arrayClientes$)[i] < (buscar($t, e.titulos$).$arrayClientes$)[i+1]{\large)}
  	\end{minipage}\vspace{3mm}
  	
  	(VIII)\begin{minipage}[t]{\linewidth-\parindent-2cm}
		($\forall$ $t$: nombre) def?($t, e.titulos$) \impluego $t$ = nombre(obtener($t$, $e.titulos$).$titulo$)
  	\end{minipage}\vspace{3mm}
  	
  \tadOperacion{est\'aCliente?}{cliente, array\_dimensionable(tuplaPorCliente)}{bool}{}
  \tadAxioma{est\'aCliente?($c, a$)}{auxEst\'aCliente($c, a, 0$)}\vspace{3mm}
  	
  \tadOperacion{auxEst\'aCliente}{cliente, array\_dimensionable(tuplaPorCliente), nat}{bool}{}
  \tadAxioma{auxEst\'aCliente($c, a$, $i$)}{{\IF $i$=longitud($a$) THEN false ELSE $a[i].cliente=c \lor$ auxEst\'aCliente($c, a, i+1$) FI}}\vspace{3mm}
  	
  
  \tadOperacion{buscarCliente}{cliente, array\_dimensionable(tuplaPorCliente)}{tuplaPorCliente}{est\'aCliente($c,a$)}
  \tadAxioma{buscarCliente($c, a$)}{auxBuscarCliente($c, a, 0$)}\vspace{3mm}
  	
  \tadOperacion{auxBuscarCliente}{cliente, array\_dimensionable(tuplaPorCliente), nat}{tuplaPorCliente}{est\'aCliente($c,a$)}
  \tadAxioma{auxBuscarCliente($c, a$, $i$)}{{\IF $a[i].cliente=c$ THEN $a[i]$ ELSE auxBuscarCliente($c, a, i+1$) FI}}

  \tadOperacion{sumaAccClientes}{array\_dimensionable(tuplaPorCliente), nat}{nat}{}
  \tadAxioma{auxBuscarCliente($a$, $i$)}{{\IF $i$=longitud($a$) THEN 0 ELSE $a[i].cantAcc$ + sumaAccClientes($a, i+1$) FI}}

  	  }\mbox{}
\subsubsection{Funci\'on de abstracci\'on}
  	 \Abs[estr]{wolfie}[e]{$w$}{clientes($w$)=$e.clientes$ $\land$ ($\forall t$: t\'itulo) {\large(}$t \in$t\'itulos($w$)$\Leftrightarrow$(def?($t, e.titulos$)\yluego$t$=obtener($t, e.titulos$).$titulo$){\large)} $\land$ ($\forall$ $c$: cliente) promesasDe($c, w$)=damePromesas(crearIt($e.titulos$), $e$, $c$) $\land$ \\accionesPorCliente($c$, $t$, $w$)=buscarCliente(obtener($t, e.titulos$).$arrayClientes$).$cantAcc$}

  \tadOperacion{damePromesas}{itDicc(diccString(infoTítulo)), estr, cliente}{conj(promesa)}{}
  \tadAxioma{damePromesas($it, e, c$)}{{\IF hayMas?($it$) THEN $\bold{if}$ buscarCliente(obtener(actual($it$))).$promCompra \neq$ NULL $\bold{then}$ \\\phantom{---}\{buscarCliente(obtener(actual($it$))).$promCompra \neq$ NULL\} $\cup$ $\bold{fi}$\\ $\bold{if}$ buscarCliente(obtener(actual($it$))).$promVenta \neq$ NULL $\bold{then}$ \\\phantom{---}\{buscarCliente(obtener(actual($it$))).$promVenta \neq$ NULL\} $\cup$ $\bold{fi}$\\ damePromesas(avanzar($it$), $e$, $c$) ELSE vacio FI}}

% para el rep, necesito las operaciones: def? y obtener de dicTrie, estaCliente? y buscarCliente de arrays de tuplas con cliente, sumaAccClientes 

\subsubsection{Representaci\'on de itT\'itulos}

\begin{Estructura}{itT\'itulos}[iterador]
    \begin{Tupla}[iterador]
      \tupItem{it}{itClaves(infoT\'itulo),}%
      	
      \tupItem{dicc}{*diccString(infoT\'itulo)}
    \end{Tupla}

\end{Estructura}

\subsubsection{Invariante de Representaci\'on de itT\'itulos}
 \renewcommand{\labelenumi}{(\Roman{enumi})}
 Los el iterador de claves es iterador del diccString.

 \Rep[iterador][i]{esIterador(i.it, CrearIt(*(i.dicc)))}
  \tadOperacion{esIterador}{itClaves(infoT\'itulo), itClaves(infoT\'itulo)}{bool}{}
  \tadAxioma{esIterador(it1, it2}{actual($it1$)=actual($it2$) $\lor$ (hayMas?($it2$) \yluego esIterador($it1$, Avanzar(it2)))}

 \Abs[iterador]{itT\'itulo}[i]{$t$}{actual(t)=obtener(actual(i.it), *(i.dicc)) $\land$ (hayM\'as(i.it)\impluego (hayM\'as(t) \yluego Abs(<Avanzar(i.it), i.dicc>, avanzar(t))))}


\subsection{Algoritmos}
\lstset { %
    showstringspaces=false,
}
\subsubsection{Algoritmos de wolfie}
iClientes(in e: estr) $\rightarrow$ res: itConjEstNat
\begin{lstlisting}[mathescape]
  return(CrearIt(e.clientes))
\end{lstlisting}
\textbf{Complejidad:} O(1)
%--------------------------falta iTitulos------------------

iPromesasDe(in c: cliente, in/out e: estr) $\rightarrow$ res: itConj(promesa)
\begin{lstlisting}[mathescape]
 if $\neg$(e.ultimoLlamado.cliente = c $\land$ e.ultimoLlamado.fueUltimo) then		O(1)
   $\textbf{itClaves(diccString(infoTitulo))}$ it $\leftarrow$ CrearIt(e.titulos)							O(1)
   $\textbf{conj(promesa)}$ proms $\leftarrow$ vacio() 								O(1)
   $\textbf{tuplaPorClientes}$ tup										O(1)
   while (HayMas?(it))						T*	   O(1)
     tup $\leftarrow$ BuscarCliente(Obtener(Nombre(Actual(it)), e. titulos).arrayClientes)	
     							O(C*|nombre(actual(it))|)
     if tup.promVenta $\neq$ NULL then AgregarRapido(proms, *(tup.promVenta))	   O(1)
     if tup.promCompra $\neq$ NULL then AgregarRapido(proms, *(tup.promCompra)) O(1)
     Avanzar(it)								O(1)
   endWhile
   e.ultimoLlamado.promesas $\leftarrow$ proms						O(1)
 fi
 return(crearIt(e.ultimoLlamado.promesas))					O(1)
\end{lstlisting}
\textbf{Complejidad:} 4*O(1)+T*(O(1)+O(C*|nombre(actual(it))|)+3*O(1))+O(1)+O(1)$\subseteq$O(T*C*|max\_nt|)

iAccionesPorCliente(in c: cliente, in nt, nombreT, in e: estr) $\rightarrow$ res: nat
\begin{lstlisting}[mathescape]
  return(BuscarCliente(c, Obtener(nt, e.titulos)).cantAcc)
\end{lstlisting}
\textbf{Complejidad:} O(log(C)+|nt|)

iInaugurarWolfie(in c: conj(cliente)) $\rightarrow$ res: estr
\begin{lstlisting}[mathescape]
  res.titulos $\leftarrow$ CrearDicc()							O(1)
  res.clientes $\leftarrow$ NuevoConjEstNat(c)					O(C(log(C)))	
  res.ultimoLlamado $\leftarrow$ <0, Vacio(), false>					O(1)
\end{lstlisting}
\textbf{Complejidad:} O(C(log(C)))

iAgregarT\'itulo(in t: t\'itulo, in/out e: estr) $\rightarrow$ res: nat
\begin{lstlisting}[mathescape]
  Definir(e.titulos, nombre(t), <CrearArrayClientes(CrearIt(e.clientes),cardinal
  	(e.clientes)), t, #maxAcciones(t))
\end{lstlisting}
\textbf{Complejidad:} O(|nombre(t)|+C)

iActualizarCotizaci\'on(in nt: nombre, in cot: nat, in/out e: estr)
\begin{lstlisting}[mathescape]
  $\textbf{infoTitulo}$ s $\leftarrow$ Obtener(nt, e.titulos) 		O(|nt|)
  recotizar(cot, s.titulo)									O(1)
  $\textbf{nat}$ i $\leftarrow$ 0										O(1)
  while i<|s.arrayClientes|						C*
    if (s.arrayClientes[i].promVenta $\neq$ NULL \yluego limite(*(s.arrayClientes[i].promVenta))
> cotizacion(s.titulo)) then									O(1)
      s.arrayClientes[i].cantAcc -= cantidad(*(s.arrayClientes[i].promVenta))	O(1)
      s.accDisponibles += cantidad(*(s.arrayClientes[i].promVenta))		O(1)
      s.arrayClientes[i].promVenta = NULL					O(1)
    fi
  endWhile
  $\textbf{arreglo\_dimensionable(tuplaPorCantAcc)[|s.arrayClientes|]}$ arr										O(C)
  CambiarPorCantAcc(s.arrayClientes, arr)					O(C)
  heapsort(arr)								    O(C(log(C)))
  i $\leftarrow$ 0										O(1)
  while i<|s.arrayClientes|						C*
    if (arr[i].promCompra $\neq$ NULL \yluego limite(*(arr[i].promCompra)) < cotizacion(s.titulo) $\land$ 
cantidad(*(arr[i].promCompra)) $\leq$ s.accDisponibles) then			O(1)
      arr[i].cantAcc += cantidad(*(arr[i].promCompra))			O(1)
      s.accDisponibles -= cantidad(*(arr[i].promCompra))		O(1)
      arr[i].promCompra = NULL						O(1)
    fi
    i++									O(1)
  endWhile
  CambiarPorCliente(arr, s.arrayClientes)					O(C)
  heapsort(s.arrayClientes)						   O(C(log(C)))
  
\end{lstlisting}
\textbf{Complejidad:} O(|nt|)+2*O(1)+C*4*O(1)+O(C)+O(C)+O(C(log(C)))+O(1)+C*4*O(1)+O(C)+O(C(log(C)))=\\\indent\indent\indent O(|nt|+C(log(C)))

iAgregarPromesa(in c: cliente, in p:promesa, in/out e:estr)
\begin{lstlisting}[mathescape]
  $\textbf{promesa}$ prom $\leftarrow$ p									O(1)
  if tipo(prom)=compra then							O(1)
   BuscarCliente(c, Obtener(titulo(prom), e.titulos).arrayClientes).promCompra $\leftarrow$ &prom
   									O(|titulo(p)|+C)
  else
   BuscarCliente(c, Obtener(titulo(prom), e.titulos).arrayClientes).promCompra $\leftarrow$ &prom
   									O(|titulo(p)|+C)
  fi
\end{lstlisting}
\textbf{Complejidad:} O(1)+O(1)+O(|titulo(p)|+C)=O(|titulo(p)|+C)

iEnAlza(in nt: nombreT, in e: estr) $\rightarrow$ res: bool
\begin{lstlisting}[mathescape]
  return(enAlza(Obtener(nt, e.titulos).titulo))
\end{lstlisting}
\textbf{Complejidad:} O(|nt|)



\subsubsection{Algoritmos de itT\'itulos}

iCrearIt(in e: estr) $\rightarrow$ res: iterador
\begin{lstlisting}[mathescape]
  return(<crearIt(e.titulos), &(e.titulos)>)
\end{lstlisting}
\textbf{Complejidad:} O(|nt|)

iActual(in i: iterador) $\rightarrow$ res: titulo
\begin{lstlisting}[mathescape]
  return(Significado(Actual(i.it), *(i.dicc)).titulo)
\end{lstlisting}
\textbf{Complejidad:} O(|nt|)

iCrearIt(in e: estr) $\rightarrow$ res: iterador
\begin{lstlisting}[mathescape]
  return(<crearIt(e.titulos), &(e.titulos)>)
\end{lstlisting}
\textbf{Complejidad:} O(|nt|)





\subsubsection{Funciones auxiliares}
CrearArrayClientes(in it: itConjEstNat, in n: nat) $\rightarrow$ res: arreglo\_dimensionable(tuplaPorClientes)
\begin{lstlisting}[mathescape]
  $\textbf{arreglo\_dimensionable(tuplaPorClientes)[n]}$ arr					O(n)
  $\textbf{nat}$ i $\leftarrow$ 0									O(1)
  do								n*
    arr[i] $\leftarrow$ <Actual(it), 0, NULL, NULL>				O(1)
    i++								O(1)
    Proximo(it)							O(1)
  while hayProx(it)						O(1)
  return arr
\end{lstlisting}
\textbf{Complejidad:} O(n)+O(1)+n*4*O(1)=O(n)

CambiarPorCantAcc(in a1: arreglo\_dimensionable(tuplaPorCliente), in/out a2: arreglo\_dimensionable(tuplaPorCantAcc))
\begin{lstlisting}[mathescape]
  $\textbf{nat}$ i $\leftarrow$ 0										O(1)
  while i<|a1|								|a1|*
    a2[i].cliente $\leftarrow$ a1[i].cliente					O(1)
    a2[i].cantAcc $\leftarrow$ a1[i].cantAcc					O(1)
    a2[i].promCompra $\leftarrow$ a1[i].promCompra					O(1)
    a2[i].promVenta $\leftarrow$ a1[i].promVenta					O(1)
    i++									O(1)
  endWhile
\end{lstlisting}
\textbf{Complejidad:} O(1)+|a1|*5*O(1)=O(|a1|)

CambiarPorCliente(in a1: arreglo\_dimensionable(tuplaPorCantAcc), in/out a2: arreglo\_dimensionable(tuplaPorCliente))
\begin{lstlisting}[mathescape]
  $\textbf{nat}$ i $\leftarrow$ 0										O(1)
  while i<|a1|								|a1|*
    a2[i].cliente $\leftarrow$ a1[i].cliente					O(1)
    a2[i].cantAcc $\leftarrow$ a1[i].cantAcc					O(1)
    a2[i].promCompra $\leftarrow$ a1[i].promCompra					O(1)
    a2[i].promVenta $\leftarrow$ a1[i].promVenta					O(1)
    i++									O(1)
  endWhile
\end{lstlisting}
\textbf{Complejidad:} O(1)+|a1|*5*O(1)=O(|a1|)

\textsc{BuscarCliente}(\textbf{in} cliente: cliente, \textbf{in} a: arreglo\_dimensionable(tuplaPorCliente)) $\rightarrow$ \textbf{res} = tuplaPorCliente
\begin{lstlisting}[mathescape]
 int: arriba $\leftarrow$ longitud(a)
 int: abajo $\leftarrow$ 0
 int: centro
 while (abajo $\leq$ arriba)
 	centro $\leftarrow$ (arriba + abajo)/2;
    if (arreglo[centro].$\Pi_{1}$ == cliente)
 		return a[centro];
    else
 		if (cliente < arreglo[centro].$\Pi_{1}$)
   			arriba $\leftarrow$ centro-1;
 		else
   			abajo $\leftarrow$ centro+1;
   		endIf
   	endIf
 endWhile
\end{lstlisting}
\textbf{Complejidad} O(log(|a|)) porque es una implementacion del algoritmo de b\'usqueda, que por lo visto en clase, tiene complejidad logar\'itmica en la longitud del arreglo.\\

\subsection{Servicios Usados}
\begin{center}
\begin{tabular*}{4\textwidth}{c |c | c }
\textbf{M\'odulo} & \textbf{Operaci\'on} & \textbf{Complejidad Requerida}\\
diccString(infoTitulo) & CrearIt & O(1)\\
diccString(infoTitulo) & Definir & |nt|\\
diccString(infoTitulo) & Obtener & |nt|\\
conj(promesa) & Vacio & O(1)\\
conj(promesa) & AgregarRapido & O(1)\\
itDicc(diccString(infoT\'itulo)) & HayM\'as & O(1)\\
itDicc(diccString(infoT\'itulo)) & Actual & O(1)\\
itDicc(diccString(infoT\'itulo)) & Avanzar & O(1)\\
& BuscarCliente & O(log(C))\\
conjEstNat & NuevoConjEstNat & O(C(log(C)))\\
itConjEstNat & CrearIt & O(1)\\
itConjEstNat & HayProx & O(1)\\
itConjEstNat & Proximo & O(1)\\
itConjEstNat & Actual & O(1)\\
arreglo\_dimensionable & CrearNuevo & O(n)\\
arreglo\_dimensionable & AgregarElemento & O(1)\\
arreglo\_dimensionable & $\bullet$[$\bullet$] & O(1)\\
& heapsort & O(n(log(n)))\\
\end{tabular*}
\end{center}
