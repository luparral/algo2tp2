\subsection{Interfaz}
%%###no tenemos no parametros formales?

  %%\InterfazFuncion{AgregarAdelante}{\Inout{l}{lista($\alpha$)}, \In{a}{$\alpha$}}{itLista($\alpha$}

%%Parámetros formales
  \subsubsection{Par\'ametros formales}
   \parbox{1.7cm}{\textbf{g\'eneros}} wolfie\\
    %%\parbox[t]{1.7cm}{\textbf{funci\'on}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
     %%\InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
     %%{$res \igobs a$}
     %%[$\Theta(copy(a))$]
     %%[funci\'on de copia de $\alpha$ s]
    %%}

  \textbf{se explica con}: \tadNombre{Wolfie}.

    %%\textbf{g\'eneros}: \TipoVariable{lista$(\alpha)$}, \TipoVariable{itLista($\alpha$)}.

%%Operaciones básicas
  \subsubsection{Operaciones b\'asicas de wolfie}
 %%clientes
  \InterfazFuncion{Clientes}{\In{w}{wolfie}}{itConjEstNat(cliente)}
  {$res$ \igobs crearItUni(clientes($w$))}
  [$\Theta(1)$]
  [Devuelve un iterador a los clientes de un wolfie.]\\\\
 %%titulos
  \InterfazFuncion{T\'itulos}{\In{w}{wolfie}}{itUni(t\'itulo)}
  {$res$ \igobs crearItUni(t\'itulos($w$))}%
  [$\Theta(1)$]
  [Devuelve un iterador a los t\'itulos de un wolfie.]\\\\
%%promesasDe
  \InterfazFuncion{PromesasDe}{\In{c}{cliente}, \In{w}{wolfie}}{itConj(promesa)}
  [$c \in$ clientes($w$)]
  {$res$ \igobs crearItUni(promesasDe($c$, $w$))}%
  [$\Theta(T \cdotp C \cdotp |max\_nt|)$]
  [Devuelve un iterador a las promesas de un wolfie]\\\\
  %%accionesPorCliente
  \InterfazFuncion{AccionesPorCliente}{\In{c}{cliente}, \In{nt}{nombre}, \In{w}{wolfie}}{$nat$}%
  [$c \in$ clientes($w$) $\land$ ($\exists$ $t$:t\'itulo) ($t \in$ t\'itulos($w$) $\land$ nombre($t$) = $nt$)]
  %%###ojo con nombreTitulo
  {$res$ \igobs accionesPorCliente($c$, $nt$, $w$)}%
  [$\Theta(log(C)+|nt|)$]
  [Devuelve la cantidad de acciones que un cliente posee de un determinado t\'itulo.]\\\\
%%inaugurarWolfie
  \InterfazFuncion{InaugurarWolfie}{\In{cs}{conj(cliente)}}{wolfie}%%&&& conj(cliente)? No rompe nada usar un conjunto aca? ---lo implementamos como vector
  [$\neg\emptyset$?($cs$)]
  {$res$ \igobs inaugurarWolfie($cs$)}
  [$\Theta(\#(cs)^2)$]
  [Crea un nuevo wolfie a partir de un conjunto de clientes.]\\\\  %%&&& la complejidad habia quedado n log n si usamos merge sort
%%agregarTitulo
  \InterfazFuncion{AgregarT\'itulo}{\In{t}{t\'itulo}, \Inout{w}{wolfie}}{}%
  [$w_{0}$ \igobs $w$ $\land$ ($\forall$ $t2$:t\'itulo) ($t2$ $\in$ t\'itulos($w$) $\Rightarrow$ nombre($t$) $\neq$ nombre($t2$)]
  {$w$ \igobs agregarT\'itulo($t$, $w_{0}$}%
  [$\Theta(|nombre(t)|+C)$]\\\\
%%actualizarCotizacion
  \InterfazFuncion{ActualizarCotizaci\'on}{\In{nt}{nombre}, \In{cot}{nat}, \Inout{w}{wolfie}}{}%
  %%### ojo con NombreTítulo
  [$w_{0}$ \igobs $w$ $\land$ ($\exists$ $t$:t\'itulo) ($t$ $\in$ t\'itulos($w$) $\land$ nombre($t$) = $nt$)]
  {$w$ $\igobs$ actualizarCotizaci\'on($nt$, $cot$, $w_{0}$)}%
  [$\Theta(C \cdotp |nt|+C \cdotp log(C))$]
  [Cambia la cotizaci\'on de un determinado t\'itulo. Esta operaci\'on genera que se desencadene el cumplimiento de promesas (seg\'un corresponda): primero de venta y luego, de compra, seg\'un el orden descendente de cantidad de acciones por t\'itulo de cada cliente.]\\\\
%%agregarPromesa
  \InterfazFuncion{AgregarPromesa}{\In{c}{cliente}, \In{p}{promesa}, \Inout{w}{wolfie}}{}%
  [$w_{0}$ \igobs $w$ $\land$ ($\exists$$t$: t\'itulo) ($t$ $\in$ t\'itulos($w$) $\land$ nombre($t$) = t\'itulo($p$)) $\land$ $c$ $\in$ clientes($w$) \yluego ($\forall$$p2$: promesa) ($p2$ $\in$ promesasDe($c$, $w$) $\Rightarrow$ (t\'itulo($p$) $\neq$ t\'itulo($p2$) $\lor$ tipo($p$) $\neq$ tipo($p2$)) ) $\land$ (tipo($p$) = vender $\Rightarrow$ accionesPorCliente($c$, t\'itulo($p$), $w$) $\geq$ cantidad($p$)))]
  {$w$ \igobs agregarPromesa($c$, $p$, $w_{0}$)}%
  [$\Theta(|t$\'i$tulo(p)| + log(C))$]
  [Agrega una nueva promesa.]\\\\
%%enAlza
  \InterfazFuncion{EnAlza}{\In{nt}{nombreT\'itulo}, \In{w}{wolfie}}{bool}%%&&& aca estaba mal la aridad
  [($\exists$$t$: t\'itulo) ($t$ $\in$ t\'itulos($w$) $\land$ nombre($t$) = nt)]
  {$res$ \igobs enAlza($nt$, $w$)}%
  [$\Theta(|nt|)$]
  [Dado un t\'itulo, informa si est\'a o no en alza.]\\\\
  %%### ojo con NombreTítulo

%%&&& las complejidades van con O grande, no con tita

\subsection{Representaci\'on}
\subsubsection{Representaci\'on de wolfie}
%------------------------estr----------------------------
\begin{Estructura}{wolfie}[estr]
    \begin{Tupla}[estr]
      \tupItem{t\'itulos}{diccTrie(nombre, infoT\'itulo),}%
      	
      \tupItem{clientes}{conjEstNat(cliente)}
      
      \tupItem{\'ultimoLlamado}{<$cliente$: cliente, $promesas$:conj(promesa), $fueUltimo$: bool>)}%
    \end{Tupla}

    \begin{Tupla}[infoT\'itulo]
    	\tupItem{arrayClientes}{array\_dimensionable(tuplaPorCliente),}
    	\tupItem{cot}{nat,}
    	\tupItem{enAlza}{bool,}
    	\tupItem{maxAcc}{nat,}
    	\tupItem{accDisponibles}{nat}
    \end{Tupla}
    
    \begin{Tupla}[tuplaPorCliente]
    	\tupItem{cliente}{cliente,}
    	\tupItem{cantAcc}{nat,}
    	\tupItem{promCompra}{*promesa,}
    	\tupItem{promVenta}{*promesa}
    \end{Tupla}
    \indent\indent Con un orden definido por $a$<$b$ $\Leftrightarrow$ $a.cliente$ < $b.cliente$
    
    \begin{Tupla}[tuplaPorCantAcc]
    	\tupItem{cliente}{cliente,}
    	\tupItem{cantAcc}{nat,}
    	\tupItem{promCompra}{*promesa,}
    	\tupItem{promVenta}{*promesa}
    \end{Tupla}
    \indent\indent Con un orden definido por $a$<$b$ $\Leftrightarrow$ $a.cantAcc$ < $b.cantAcc$

\end{Estructura}
 %----------------------------------------------------Rep------------------------------------------
\subsubsection{Invariante de representaci\'on}
 \renewcommand{\labelenumi}{(\Roman{enumi})}
 \begin{enumerate}
 	\item Los clientes de $clientes$ son los mismos que hay dentro de $titulos$.
 	\item Las promesas de compra  son de su t\'itulo y cliente y no cumplen los requisitos para ejecutarse.
 	\item Las promesas de y venta son de su t\'itulo y cliente y no cumplen los requisitos para ejecutarse.
 	\item Las acciones disponibles de cada t\'itulo son el m\'aximo de acciones de ese t\'itulo menos la suma de las acciones de ese titulo que tengan los clientes, y son mayores o iguales a 0.
 	\item El $cliente$ de $\acute{u}ltimoLlamado$ pertenece a $clientes$.
 	\item En $\acute{u}ltimoLlamado$, si $fue\acute{U}ltimo$ es true, las promesas de $promesas$ son todas las promesas que tiene $cliente$.
 	\item Los clientes est\'an ordenados en $arrayClientes$ de $e.titulos$.
  \end{enumerate}
  
  \Rep[estr][e]{\\
 	(I)\begin{minipage}[t]{\linewidth-\parindent-1.3cm}
  		($\forall$ $c$: cliente) {\Large(}pertenece?($c$, $e.clientes$) $\Leftrightarrow$ ($\exists$ $t$: t\'itulo) {\large(}def?($t$, $e.titulos$) \yluego est\'aCliente?($c$, obtener($t$, $e.titulos$).$arrayClientes$){\large)}{\Large)} \yluego
  	\end{minipage}\vspace{3mm}

  	(II)\begin{minipage}[t]{\linewidth-\parindent-1.3cm}
  		($\forall$ $p$: $*$promesa, $t$: nombre, $c$: cliente) {\large(}(p $\neq$ NULL $\land$ def?($t$, $e.titulos$) \yluego  est\'aCliente?($c$, obtener($t$, $e.titulos$).$arrayClientes$) \yluego buscarCliente($c$, obtener($t$, $e.titulos$).$arrayClientes$).$promCompra$=$p$) \impluego  t\'itulo($*p$)=$t$ $\land$ tipo($*p$)=compra $\land$ (l\'imite($*p$)>obtener($t$, $e.titulos$).$cot$ $\lor$ cantidad($*p$)>obtener($t$, $e.titulos$).$accDisponibles$){\large)} $\land$
  	\end{minipage}\vspace{3mm}
  	
  	(III)\begin{minipage}[t]{\linewidth-\parindent-1.3cm}
  		($\forall$ $p$: $*$promesa, $t$: nombre, $c$: cliente) {\large(}(p $\neq$ NULL $\land$ def?($t$, $e.titulos$) \yluego  est\'aCliente?($c$, obtener($t$, $e.titulos$).$arrayClientes$) \yluego buscarCliente($c$, obtener($t$, $e.titulos$).$arrayClientes$).$promVenta$=$p$) \impluego (t\'itulo($*p$)=$t$ $\land$ tipo($*p$)=venta $\land$ l\'imite($*p$) < obtener($t$, $e.titulos$).$cot$){\large)} $\land$
  	\end{minipage}\vspace{3mm}
  	
  	(IV)\begin{minipage}[t]{\linewidth-\parindent-2cm}
		($\forall$ $nt$: nombreT) (def?($nt$, $e.titulos$) \impluego (obtener($nt$, $e.titulos$).$accDisponibles$ = obtener($nt$, $e.titulos$).$maxAcc$ - sumaAccClientes(obtener($nt$, $e.titulos$).$arrayClientes$, 0) $\land$ obtener($nt$, $e.titulos$).$accDisponibles$ $\geq$ 0)) $\land$
  	\end{minipage}\vspace{3mm}
  	
  	(V)\begin{minipage}[t]{\linewidth-\parindent-2cm}
		(pertenece?($e.\acute{u}ltimoLlamado.cliente$, $e.clientes$)) \yluego
  	\end{minipage}\vspace{3mm}
  	
	(VI)\begin{minipage}[t]{\linewidth-\parindent-2cm}
		($e.\acute{u}ltimoLlamado.fue\acute{U}ltimo$ $\Rightarrow$ ($\forall$ $p$: promesa) {\Large(}pertenece?($p$, $e.\acute{u}ltimoLlamado.promesas$) $\Leftrightarrow$ {\large(}def?(t\'itulo($p$), $e.titulos$) \yluego \\ {\IF tipo($p$)=compra THEN buscarCliente($e.\acute{u}ltimoLlamado.cliente$, obtener(t\'itulo($p$), $e.titulos$).$arrayClientes$).promCompra = $p$ ELSE buscarCliente($e.\acute{u}ltimoLlamado.cliente$, obtener(t\'itulo($p$), $e.titulos$).$arrayClientes$).promVenta = $p$ FI}{\large)}{\Large)}
  	\end{minipage}\vspace{3mm}
  	
  	(VII)\begin{minipage}[t]{\linewidth-\parindent-2cm}
		($\forall$ $t$: t\'itulo) def?($t, e.titulos$) \impluego {\large(}($\forall$ $i$:nat) i<longitud(buscar($t, e.titulos$).$arrayClientes$)-1 $\Rightarrow$ (buscar($t, e.titulos$).$arrayClientes$)[i] < (buscar($t, e.titulos$).$arrayClientes$)[i+1]{\large)}
  	\end{minipage}\vspace{3mm}
  	
  \tadOperacion{est\'aCliente?}{cliente, array\_dimensionable(tuplaPorCliente)}{bool}{}
  \tadAxioma{est\'aCliente?($c, a$)}{auxEst\'aCliente($c, a, 0$)}\vspace{3mm}
  	
  \tadOperacion{auxEst\'aCliente}{cliente, array\_dimensionable(tuplaPorCliente), nat}{bool}{}
  \tadAxioma{auxEst\'aCliente($c, a$, $i$)}{{\IF $i$=longitud($a$) THEN false ELSE $a[i].cliente=c \lor$ auxEst\'aCliente($c, a, i+1$) FI}}\vspace{3mm}
  	
  
  \tadOperacion{buscarCliente}{cliente, array\_dimensionable(tuplaPorCliente)}{tuplaPorCliente}{est\'aCliente($c,a$)}
  \tadAxioma{buscarCliente($c, a$)}{auxBuscarCliente($c, a, 0$)}\vspace{3mm}
  	
  \tadOperacion{auxBuscarCliente}{cliente, array\_dimensionable(tuplaPorCliente), nat}{tuplaPorCliente}{est\'aCliente($c,a$)}
  \tadAxioma{auxBuscarCliente($c, a$, $i$)}{{\IF $a[i].cliente=c$ THEN $a[i]$ ELSE auxBuscarCliente($c, a, i+1$) FI}}

  \tadOperacion{sumaAccClientes}{array\_dimensionable(tuplaPorCliente), nat}{nat}{}
  \tadAxioma{auxBuscarCliente($a$, $i$)}{{\IF $i$=longitud($a$) THEN 0 ELSE $a[i].cantAcc$ + sumaAccClientes($a, i+1$) FI}}

  	  }\mbox{}
\subsubsection{Funci\'on de abstracci\'on}
  	 \Abs[estr]{wolfie}[e]{$w$}{clientes($w$)=$e.clientes$ $\land$ t\'itulos($w$)=????????? $\land$ \\($\forall$ $c$: cliente) promesasDe($c, w$)=damePromesas(crearIt($e.titulos$), $e$, $c$) $\land$ \\accionesPorCliente($c$, $t$, $w$)=buscarCliente(obtener($t, e.titulos$).$arrayClientes$).$cantAcc$}

  \tadOperacion{damePromesas}{itDicc(diccString), estr, cliente}{conj(promesa)}{}
  \tadAxioma{damePromesas($it, e, c$)}{{\IF hayMas?($it$) THEN $\bold{if}$ buscarCliente(obtener(actual($it$))).$promCompra \neq$ NULL $\bold{then}$ \\\phantom{---}\{buscarCliente(obtener(actual($it$))).$promCompra \neq$ NULL\} $\cup$ $\bold{fi}$\\ $\bold{if}$ buscarCliente(obtener(actual($it$))).$promVenta \neq$ NULL $\bold{then}$ \\\phantom{---}\{buscarCliente(obtener(actual($it$))).$promVenta \neq$ NULL\} $\cup$ $\bold{fi}$\\ damePromesas(avanzar($it$), $e$, $c$) ELSE vacio FI}}

% para el rep, necesito las operaciones: def? y obtener de dicTrie, estaCliente? y buscarCliente de arrays de tuplas con cliente, sumaAccClientes 

\subsection{Algoritmos}
\lstset { %
    showstringspaces=false,
}
iClientes(in e: estr) $\rightarrow$ res: itConjEstNat
\begin{lstlisting}[mathescape]
  return(CrearIt(e.clientes))
\end{lstlisting}

%--------------------------falta iTitulos------------------

iPromesasDe(in c: cliente, in/out e: estr) $\rightarrow$ res: itConj(promesa)
\begin{lstlisting}[mathescape]
 if $\neg$(e.ultimoLlamado.cliente = c $\land$ e.ultimoLlamado.fueUltimo) then
   $\textbf{itClaves(diccString)}$ it $\leftarrow$ crearIt(e.titulos)
   $\textbf{conj(promesa)}$ proms $\leftarrow$ vacio() 
   $\textbf{tuplaPorClientes}$ tup
   while (HayMas?(it))
     tup $\leftarrow$ BuscarCliente(Obtener(Nombre(Actual(it)), e. titulos).arrayClientes)
     if tup.promVenta $\neq$ NULL then AgregarRapido(proms, *(tup.promVenta))
     if tup.promCompra $\neq$ NULL then AgregarRapido(proms, *(tup.promCompra))
     Avanzar(it)
   endWhile
   e.ultimoLlamado.promesas $\leftarrow$ proms
 fi
 return(crearIt(e.ultimoLlamado.promesas)
\end{lstlisting}

iAccionesPorCliente(in c: cliente, in nt, nombreT, in e: estr) $\rightarrow$ res: nat
\begin{lstlisting}[mathescape]
  return(BuscarCliente(c, Obtener(nt, e.titulos)).cantAcc)
\end{lstlisting}

iInaugurarWolfie(in c: conj(cliente)) $\rightarrow$ res: estr
\begin{lstlisting}[mathescape]
  res.titulos $\leftarrow$ CrearDicc()
  res.clientes $\leftarrow$ CrearDicc()
  res.ultimoLlamado $\leftarrow$ <0, Vacio(), false>
\end{lstlisting}

iAgregarPromesa(in c: cliente, in p:promesa, in/out e:estr)
\begin{lstlisting}[mathescape]
  $\textbf{promesa}$ prom $\leftarrow$ p
  if tipo(prom)=compra then
   BuscarCliente(c, Obtener(titulo(prom), e.titulos).arrayClientes).promCompra $\leftarrow$ &prom
  else
   BuscarCliente(c, Obtener(titulo(prom), e.titulos).arrayClientes).promCompra $\leftarrow$ &prom
  fi
\end{lstlisting}

iEnAlza(in nt: nombreT, in e: estr) $\rightarrow$ res: bool
\begin{lstlisting}[mathescape]
  return(Obtener(nt, e.titulos).enAlza)
\end{lstlisting}

iAgregarT\'itulo(in t: titulo, in/out e: estr) $\rightarrow$ res: nat
\begin{lstlisting}[mathescape]
  Definir(e.titulos, nombre(t), <CrearArrayClientes(CrearIt(e.clientes),cardinal
  	(e.clientes)), cotizacion(t), enAlza(t), #maxAcciones(t), #maxAcciones(t))
\end{lstlisting}


\subsubsection{Funciones auxiliares}
CrearArrayClientes(in it: itConjEstNat, in n: nat) $\rightarrow$ res: arreglo\_dimensionable(tuplaPorClientes)
\begin{lstlisting}[mathescape]
  $\textbf{arreglo\_dimensionable(tuplaPorClientes)[n]}$ arr
  $\textbf{nat}$ i $\leftarrow$ 0
  do
  	arr[i] $\leftarrow$ <Actual(it), 0, NULL, NULL>
  	i++
  	Proximo(it)
  while hayProx(it)
  return arr
\end{lstlisting}


