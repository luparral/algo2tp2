\documentclass{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage{fancyhdr}
	
\pagestyle{fancy}
\thispagestyle{fancy}
\addtolength{\headheight}{1pt}
\lhead{Trabajo Pr\'{a}ctico 2}
\rhead{Grupo 16}
	
	
\begin{document}
\section*{M\'odulo Diccionario Rapido($\alpha$)}

\subsection*{Interfaz}

\hspace{0.5cm} \textbf{par\'ametros formales}

\hspace{0.75cm} \textbf{g\'eneros} $string,\alpha$

\hspace{0.75cm} \textbf{se explica con:} \textsc{$Diccionario(clave, significado)$}

\hspace{0.75cm} \textbf{g\'eneros:} \textsc{$diccRap(\alpha)$}

\subsection*{Operaciones b\'asicas de DiccRap($\alpha$)}

\hspace{0.5cm} \textsc{CrearDicc}() $\rightarrow$ \ $res$:diccRap($\alpha$)

\hspace{0cm} \textbf{Pre} $\equiv$ $\lbrace$true$\rbrace$

\hspace{0cm} \textbf{Post} $\equiv$ $\lbrace$res$=_{obs}$ vacio$\rbrace$

\hspace{0cm} \textbf{Complejidad}: O(1)

\hspace{0cm} \textbf{Descripcion}: Crea un diccionario vacio
\\

\hspace{0cm} \textsc{Definir}(\textbf{in/out} $d$: diccRap($\alpha$), \textbf{in} $c$: string, \textbf{in} $s$:conj($\alpha$))

\hspace{0cm} \textbf{Pre} $\equiv$ $\lbrace$ d$=_{obs}$ d$_{0}$ $\wedge$ $\neg$definido?(d,c)$\rbrace$

\hspace{0cm} \textbf{Post} $\equiv$ $\lbrace$ d $=_{obs}$ definir($d_{0}$,c,s) $\rbrace$

\hspace{0cm} \textbf{Complejidad}: O(long(c))

\hspace{0cm} \textbf{Descripcion}: define la clave c con el significado en el diccionario.
\\

\hspace{0cm} \textsc{Definido?}(\textbf{in} $d$: diccRap($\alpha$), \textbf{in} $c$:string) $\rightarrow$ $res$:bool

\hspace{0cm} \textbf{Pre} $\equiv$ $\lbrace$true$\rbrace$

\hspace{0cm} \textbf{Post} $\equiv$ $\lbrace$ res $=_{obs}$ def?(c,d) $\rbrace$

\hspace{0cm} \textbf{Complejidad}: O(long(c))

\hspace{0cm} \textbf{Descripcion}: devuelve true si y solo si c esta en el diccionario
\\

\hspace{0cm} \textsc{Significado}(\textbf{in} $d$: diccRap($\alpha$), \textbf{in} $c$:string) $\rightarrow$ $res$:$\alpha$

\hspace{0cm} \textbf{Pre} $\equiv$ $\lbrace$ def?(c,d) $\rbrace$

\hspace{0cm} \textbf{Post} $\equiv$ $\lbrace$ res $=_{obs}$ obtener(c,d) $\rbrace$

\hspace{0cm} \textbf{Complejidad}: O(long(c))

\hspace{0cm} \textbf{Descripcion}: devuelve el significado con clave c

\hspace{0cm} \textbf{Aliasing}: No se devuelve una copia del alpha en res, se devuelva una referencia a la original.
\\

\hspace{0cm} \textsc{SignificadosHijos}(\textbf{in/out} $d$:diccRap($\alpha$), \textbf{in} $s$:string) $\rightarrow$ $res$:conj($\alpha$) 

\hspace{0cm} \textbf{Pre} $\equiv$ $\lbrace$ true $\rbrace$

\hspace{0cm} \textbf{Post} $\equiv$ $\lbrace$ ($\forall$ a:$\alpha$) a $\in$ res $\Rightarrow$ ($\exists$ c: clave) c $\in$ claves(d) $\wedge_{L}$ a = obtener(d,c) $\wedge$ coincide(s,c) $\rbrace$

\hspace{0cm} \textbf{Complejidad}: \textsc{O}(long(s) + $\#$claves(p)) $\times$ log($\#$claves(p)) $\times$ \textit{l})

\hspace{0cm} \textbf{Descripcion}: devuelve todos los significados guardados en el diccionario d que tienen clave con prefijo s

\hspace{0cm} \textbf{Aliasing}: res no es modificable
\\

\hspace{0cm} \textsc{TodosLosSignificados}(\textbf{in/out} $d$:diccRap($\alpha$)) $\rightarrow$ $res$:conj($\alpha$) 

\hspace{0cm} \textbf{Pre} $\equiv$ $\lbrace$ true $\rbrace$

\hspace{0cm} \textbf{Post} $\equiv$ $\lbrace$ ($\forall$ a:$\alpha$) a $\in$ res $\Rightarrow$ ($\exists$ c: clave) c $\in$ claves(d) $\wedge_{L}$ a = obtener(d,c) $\rbrace$

\hspace{0cm} \textbf{Complejidad}: \textsc{O}($\#$claves(d)) $\times$ log($\#$claves(d)) $\times$ \textit{l})

\hspace{0cm} \textbf{Descripcion}: devuelve todos los significados guardados en el diccionario d

\hspace{0cm} \textbf{Aliasing}: res no es modificable
\\

\subsection*{Representacion}

\hspace{0.5cm} diccRap($\alpha$) se representa con \textbf{dic}

\hspace{0cm} donde \textbf{dic} es arreglo$\_$dimensionable de tuplas

\hspace{0cm} donde tuplas es $<$ptrDic:puntero(dic), ptrSignificado: puntero($\alpha)>$
\\

\hspace{0cm} \textbf{Rep}: dic d $\rightarrow$ bool

\hspace{0.5cm} Rep(d) $\equiv$ tam(d) = 27 $\wedge$ ($\forall$ i:nat) i $<$ tam(d) $\Rightarrow$ ($\forall$ p: puntero) p = d[i].ptrDic $\wedge_{L}$ p != NULL $\Rightarrow$ Rep(*p)
\\
 
\hspace{0cm} \textbf{Abs}(d) $\equiv$ d':diccRap($\alpha$) $|$

\hspace{0.5cm} ($\forall$ c: string) def?(c,d') $=_{obs}$ (recorre(c,d).ptrSignificado = NULL) $\wedge$

\hspace{0.5cm} ($\forall$ c: string) def?(c,d) $\rightarrow$ obtener(c,d') $=_{obs}$ (recorre(c,d).ptrSignificado)
\\

{\textbf{Funcion Auxiliar}}

\hspace{0.5cm} recorre: string c $\times$ diccRap($\alpha$) d $\rightarrow$ tuplas \ \ \ \ \ \{def?(c,d)\}
\\

\hspace{0.5cm} recorre(c,d) $\equiv$ \textbf{if} long(c) = 1 \textbf{then} d[ord(prim(c))] \textbf{else} 

\hspace{0.5cm} recorre(ult(c), *(d[ord(prim(c))].ptrDic)) \textbf{fi}

\subsection*{Algoritmos}

\hspace{0.5cm} \textsc{iCrearDicc}() $\rightarrow$ $res$: dic
\\

\hspace{0.5cm} d: arreglo(tuplas)

\hspace{0.5cm} j:nat

\hspace{0.5cm} d $\leftarrow$ CrearArreglo[27] \hfill \textsc{O}(27)

\hspace{0.5cm} j $\leftarrow$ 0 \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{while} j $<$ 27 \hfill \textsc{O}(27)

\hspace{1cm} d[j].ptrTrie $\leftarrow$ NULL\hfill \textsc{O}(1)

\hspace{1cm} d[j].ptrSignificado $\leftarrow$ NULL \hfill \textsc{O}(1)

\hspace{1cm} j++ \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{endwhile}
\\

\hspace{0.5cm} \textbf{\textsc{Complejidad:}} \textsc{O}(1)
\\

\hspace{0cm} \textsc{iDefinir}(\textbf{in/out} $d$:dic, \textbf{in} $c$:string, \textbf{in} $s$: $\alpha$)
\\

\hspace{0.5cm} j:nat

\hspace{0.5cm} p:dic

\hspace{0.5cm} i:nat

\hspace{0.5cm} j $\leftarrow$ 0  \hfill \textsc{O}(1)

\hspace{0.5cm} p $\leftarrow$ d  \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{while} j $<$ Longitud(c) - 1 \hfill \textsc{O}(long(c)-1)

\hspace{1cm} i $\leftarrow$ ord(c[j]) \hfill \textsc{O}(1)

\hspace{1cm} \textbf{if} p[i].ptrTrie = NULL \textbf{then} \hfill \textsc{O}(1)
 
\hspace{1.5cm} p[i].ptrTrie $\leftarrow$ $\&$iCrearDicc() \hfill \textsc{O}(1)

\hspace{1cm} \textbf{fi}

\hspace{1cm} p $\leftarrow$ *(p[i].ptrTrie) \hfill \textsc{O}(1)

\hspace{1cm} j++ \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{endwhile}

\hspace{0.5cm} i $\leftarrow$ ord(c[j]) \hfill \textsc{O}(1)

\hspace{0.5cm} p[i].ptrSignificado $\leftarrow$ $\&$s \hfill \textsc{O}(1)
\\

\hspace{0.5cm} \textbf{\textsc{Complejidad:}} \textsc{O}(long(c))
\\

\hspace{0cm} \textsc{iSignificado}(\textbf{in} $d$:dic, \textbf{in} $c$:string) $\rightarrow$ $res$: ($\alpha$)
\\

\hspace{0.5cm} j:nat

\hspace{0.5cm} p:dic

\hspace{0.5cm} i:nat

\hspace{0.5cm} j $\leftarrow$ 0 \hfill \textsc{O}(1)

\hspace{0.5cm} p $\leftarrow$ d \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{while} j $<$ Longitud(c) - 1 \hfill \textsc{O}(long(c)-1)

\hspace{1cm} i $\leftarrow$ ord(c[j]) \hfill \textsc{O}(1)

\hspace{1cm} p $\leftarrow$ *(p[i].ptrTrie) \hfill \textsc{O}(1)

\hspace{1cm} j++ \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{endwhile}

\hspace{0.5cm} i $\leftarrow$ ord(c[j]) \hfill \textsc{O}(1)

\hspace{0.5cm} res $\leftarrow$ *(p[i].ptrSignificado) \hfill \textsc{O}(1)
\\

\hspace{0.5cm} \textbf{\textsc{Complejidad:}} \textsc{O}(long(c))
\\

\hspace{0cm} \textsc{iDefinido?}(\textbf{in} $d$:dic, \textbf{in} $c$:string) $\rightarrow$ $res$: bool
\\

\hspace{0.5cm} j:nat

\hspace{0.5cm} p:dic

\hspace{0.5cm} j $\leftarrow$ 0 \hfill \textsc{O}(1)

\hspace{0.5cm} p $\leftarrow$ d \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{while} j $<$ Longitud(c) - 1 \hfill \textsc{O}(long(c)-1)

\hspace{1cm} i $\leftarrow$ ord(c[j]) \hfill \textsc{O}(1)

\hspace{1cm} p $\leftarrow$ *(p[i].ptrTrie) \hfill \textsc{O}(1)

\hspace{1cm} j++ \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{endwhile}

\hspace{0.5cm} i $\leftarrow$ ord(c[j]) \hfill \textsc{O}(1)

\hspace{0.5cm} res $\rightarrow$ (p[i].ptrSignificado != NULL) \hfill \textsc{O}(1)
\\

\hspace{0.5cm} \textbf{\textsc{Complejidad:}} \textsc{O}(long(c))
\\

\hspace{0cm} \textsc{SignificadosHijos}(\textbf{in/out} $d$:dic, \textbf{in} $s$: string) $\rightarrow$ conj($\alpha$) 

\hspace{0.5cm} i:nat

\hspace{0.5cm} j:nat

\hspace{0.5cm} p:dic

\hspace{0.5cm} j $\leftarrow$ 0 \hfill \textsc{O}(1)

\hspace{0.5cm} p $\leftarrow$ d \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{while} j $<$ Longitud(s) - 2 $\wedge$ p != Vacia() \hfill \textsc{O}(long(s)-2)

\hspace{1cm} i $\leftarrow$ ord(s[j]) \hfill \textsc{O}(1)

\hspace{1cm} \textbf{if} p[i].ptrDic = NULL \textbf{then} \hfill \textsc{O}(1)

\hspace{1.5cm} p $\leftarrow$ Vacia() \hfill \textsc{O}(1)

\hspace{1cm} \textbf{else}

\hspace{1.5cm} p $\leftarrow$ *(p[i].ptrDic) \hfill \textsc{O}(1)

\hspace{1.5cm} j++ \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{endwhile} 

\hspace{0.5cm} \textbf{if} p = Vacia() \textbf{then} \hfill \textsc{O}(1)

\hspace{1cm} res $\leftarrow$ Vacio() \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{else}

\hspace{1cm} res $\leftarrow$ todosLosSignificados(p) \hfill \textsc{O}($\#$claves(p)) $\times$ log($\#$claves(p)) $\times$ \textit{l})

\hspace{0.5cm} \textbf{fi}
\\

\hspace{0.5cm} \textbf{\textsc{Complejidad:}} \textsc{O}(long(s) + $\#$claves(p)) $\times$ log($\#$claves(p)) $\times$ \textit{l})
\\

\hspace{0.5cm} donde \textbf{\textit{l}} es la complejidad de comparar dos $\alpha$
\\

\hspace{0cm} \textsc{TodosLosSignificados}(\textbf{in/out} $d$:dic) $\rightarrow$ conj($\alpha$) 

\hspace{0.5cm} j:nat

\hspace{0.5cm} p:dic

\hspace{0.5cm} res $\leftarrow$ Vacio() \hfill \textsc{O}(1)

\hspace{0.5cm} j $\leftarrow$ 0 \hfill \textsc{O}(1)

\hspace{0.5cm} p $\leftarrow$ d \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{while} j $<$ 27  \hfill \textsc{O}(27)

\hspace{1cm} \textbf{if} p[j].ptrSignificado != NULL \textbf{then}  \hfill \textsc{O}(1)

\hspace{1.5cm} it $\leftarrow$ Agregar(res, *(p[j].ptrSignificado))  \hfill \textsc{O}($\#$claves(d) $\times$ \textit{l})

\hspace{1.5cm} \textbf{if} p[j].ptrDic != NULL \textbf{then}  \hfill \textsc{O}(1)

\hspace{2cm} res $\leftarrow$ UnionPosta(res, TodosLosSignificados(*(p[j].ptrdic))) \hfill \textsc{O}($\#$claves(d)) $\times$ log($\#$claves(d)) $\times$ \textit{l})

\hspace{1.5cm} \textbf{fi}

\hspace{1cm} \textbf{fi}

\hspace{1cm} j++  \hfill \textsc{O}(1)

\hspace{0.5cm} \textbf{endwhile}
\\

\hspace{0.5cm} \textbf{\textsc{Complejidad de la funcion:}} \textsc{O}($\#$claves(d)) $\times$ log($\#$claves(d)) $\times$ \textit{l})
\\

\hspace{0.5cm} donde \textbf{\textit{l}} es el costo de la comparacion entre dos $\alpha$
\\

\hspace{0.5cm} \textbf{Por el Teorema Maestro}:
\\

\hspace{1cm} T(n) = 27 * T(n/27) + (n $\times$ log(n) $\times$ \textit{l})
\\

\hspace{1cm} donde \textbf{n} es $\#$claves(d) y \textbf{\textit{l}} lo tomo como una constante significativa
\\

\hspace{1cm} como f(n) = (n $\times$ log(n) $\times$ \textit{l}) $\in$ \textbf{$\Omega$}($n^{log_{b}(a) + \epsilon})$
\\

\hspace{1cm} entonces T(n) $\in$ \textbf{$\Theta$}(f(n))

\end{document}