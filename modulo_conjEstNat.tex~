
\subsection{Interfaz}

%%Parámetros formales
   \parbox{1.7cm}{\textbf{g\'eneros}} conjEstNat, itConjEstNat\\
    %%\parbox[t]{1.7cm}{\textbf{funci\'on}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
     %%\InterfazFuncion{Copiar}{\In{a}{EstNat}}{EstNat}
     %%{$res \igobs a$}
     %%[$\Theta(copy(a))$]
     %%[funci\'on de copia de EstNat s]
    %%}

  \textbf{Se explica con}: \tadNombre{Conjunto(nat)}, \tadNombre{Iterador Unidireccional(nat)}.
  \textbf{Usa}: \
    %%\textbf{g\'eneros}: \TipoVariable{lista$(\alpha)$}, \TipoVariable{itLista(EstNat)}.

%%Operaciones básicas
  \subsubsection{Operaciones b\'asicas de conjEstNat}
 %%clientes
  \InterfazFuncion{NuevoConjEstNat}{\In{c}{conj(nat)}}{conjEstNat}
  {$res$ \igobs c}
  [$O(n*(log (n)))$]
  [Crea un conjunto est\'atico de nats]\\\\
  
  \InterfazFuncion{Pertenece?}{\In{n}{nat}, \In{c}{conjEstNat}}{bool}
  {$res$ \igobs n $\in$ c}
  [$O(n)$]
  [Pregunta si el elemento pertenece al conjunto]\\\\

  \InterfazFuncion{Cardinal}{\In{c}{conjEstNat}}{nat}
  {$res$ \igobs \#$c$}
  [$O(n)$]
  [Devuelve la cantidad de elementos que hay en el conjunto]\\\\  
  \subsubsection{Operaciones b\'asicas de itConjEstNat}  
  
  \InterfazFuncion{CrearIt}{\In{c}{conjEstNat}}{itConjEstNat}
  {$res$ \igobs crearItUni($c$)}
  [$O(1)$]
  [Devuelve un iterador unidireccional a un conjunto est\'atico de nats]\\\\
  
  \InterfazFuncion{Actual}{\In{i}{itConjEstNat}}{nat}
  {$res$ \igobs actual($i$)}
  [$O(1)$]
  [Devuelve la posicion actual]\\\\
  
  \InterfazFuncion{Pr\'oximo}{\In{i}{itConjEstNat}}{itConjEstNat}
  [hayMas?($i$)]
  {$res$ \igobs avanzar($i$)}
  [$O(1)$]
  [Avanza el iterador]\\\\
  
  \InterfazFuncion{HayPr\'ox?}{\In{i}{itConjEstNat}}{bool}
  [$i_{0}$ = $i$]
  {$res$ \igobs hayMas?($i$}
  [$O(1)$]
  [Pregunta si hay mas elementos para iterar]\\\\
\subsection{Representaci\'on}
%------------------------estr----------------------------
\subsubsection{Representaci\'on de conjEstNat}
\begin{Estructura}{conjEstNat}[array: arreglo\_dimensionable(nat)]\end{Estructura}
 	Rep: los elementos estan ordenados y no hay repeticiones
 	\Rep[array][a]{($\forall$ $i$: nat) ($i$ < longitud($a$)-1 $\Rightarrow$ (definido?($a$, $i$) $\land$ definido?($a$, $i+1$) \yluego $a[i]$<$a[i+1]$))}
  \subsubsection{Funci\'on de abstracci\'on de conjEstNat}
 	
 	\Abs[array]{conjEstNat}[a]{$c$}{($\forall$ $n$: nat) $n \in c \Leftrightarrow$ est\'aEnArray?($n$, $a$, 0)}
 	
  \tadOperacion{est\'aEnArray?}{nat, arreglo\_dimensionable(nat), nat}{bool}{}
  \tadAxioma{est\'aEnArray($n, a, i$)}{{\IF $i$= longitud($a$)-1 THEN false ELSE $a[i]=n$ $\lor$ est\'aEnArray?($n, a, i+1$) FI}}
 	
\subsubsection{Representaci\'on de itConjEstNat}
\begin{Estructura}{itConjEstNat}[iterador]
	\begin{Tupla}[iterador]
		\tupItem{pos}{nat,} 
		\tupItem{lista}{puntero(arreglo\_dimensionable(nat))}
	\end{Tupla}
\end{Estructura}

	\Rep[iterador][i]{$i.pos$<longitud($*(i.lista)$)}
  \subsubsection{Funci\'on de abstracci\'on de itConjEstNat}
	
	\Abs[iterador]{itConjEstNat}[it]{$iConj$}{actual($iConj$) = $a[i]$ $\land$ hayPr\'ox($iConj$)=($i.pos$<longitud($*(i.lista)$)-1) $\land$ \\(hayPr\'ox($i.Conj$)$\Rightarrow$pr\'oximo($iConj$)=Abs(<$i.pos+1, i.lista$>))}
	
\subsection{Algoritmos}
\subsubsection{Algoritmos de conjEstNat}
iNuevoConjEstNat(in c: conj(nat)) $\rightarrow$ res: array
\begin{lstlisting}[mathescape]
 $\textbf{itConj(nat)}$ it $\leftarrow$ crearIt(c))								O(1)
 $\textbf{arreglo\_dimensionable(nat)[cardinal(c)]}$ a										O(n)
 $\textbf{nat}$ i $\leftarrow$ 0										O(1)
 while (HaySiguiente?(it))						n*
 	a[i] $\leftarrow$ Siguiente(it)						O(1)
 	i++								O(1)
 	Avanzar(it)							O(1)
 endWhile
 heapsort(a)						  		  O(n(log(n)))
 return(a)
\end{lstlisting}
\textbf{Complejidad:} O(1)+O(n)+O(1)+n*(O(1)+O(1)+O(1))+O(n(log(n))) = O(n(log(n)))\\
\textbf{Aclaraciones:}Utilizamos el algoritmo \textsc{Heapsort} provisto en el apunte \textsc{Algoritmos b\'asicos}, con las complejidades all\'i descriptas.


iPertenece(in n: nat, in c: array) $\rightarrow$ res: bool
\begin{lstlisting}[mathescape]
 $\textbf{bool}$ b $\leftarrow$ false									O(1)
 $\textbf{nat}$ i $\leftarrow$ 0										O(1)
 while (i<|c|)								n*
 	b $\leftarrow$ (b $\lor$ c[i]=n)							O(1)
 	i++								O(1)
 endWhile
 return(b)
\end{lstlisting}
\textbf{Complejidad:} O(1)+O(1)+n*(O(1)+O(1)) = O(n)\\

\subsubsection{Algoritmos de itConjEstNat}
iCrearIt(in a: array) $\rightarrow$ res: iterador
\begin{lstlisting}[mathescape]
 return (<|c|, &c>)
\end{lstlisting}
\textbf{Complejidad:} O(1)\\

iActual(in it: iterador) $\rightarrow$ res: nat
\begin{lstlisting}[mathescape]
 return (*(it.lista))[it.pos]
\end{lstlisting}
\textbf{Complejidad:} O(1)\\

iActual(in/out it: iterador)
\begin{lstlisting}[mathescape]
 return <it.pos+1, it.lista>
\end{lstlisting}
\textbf{Complejidad:} O(1)\\

iHayPr\'oximo?(in it: iterador) $\rightarrow$ res: bool
\begin{lstlisting}[mathescape]
 return (it.pos+1<longitud(it.lista))
\end{lstlisting}
\textbf{Complejidad:} O(1)\\

Servicios usados: se utlilzan solo tipos basicos, incluidos arreglos y punteros.

\subsection{Servicios Usados}
\begin{center}
\begin{tabular*}{2.75\textwidth}{c |c | c }
\textbf{M\'odulo} & \textbf{Operaci\'on} & \textbf{Complejidad Requerida}\\
arreglo\_est\'atico & CrearNuevo & O(n)\\
arreglo\_est\'atico & AgregarElemento & O(1)\\
arreglo\_est\'atico & $\bullet$[$\bullet$] & O(1)\\
& heapsort & O(n(log(n)))\\
\end{tabular*}
\end{center}


\subsection {TAD \tadNombre{Conjunto Est\'atico de Nats}}

\begin{tad}{\tadNombre{Conjunto Est\'atico de Nats}}
\tadIgualdadObservacional{c}{c'}{conjEstNat}{$(\forall a: nat)(a \in c \igobs a \in c')$}

\tadGeneros{conjEstNat}
\tadExporta{conjEstNat, generadores, observadores, \#}
\tadUsa{\tadNombre{Bool, Nat, Conjunto(nat)}}

\tadAlinearFunciones{crearconjestnat}{conj(EstNat),conj(EstNat)}

\tadObservadores
\tadOperacion{\argumento $\in$ \argumento}{nat,conjEstNat}{bool}{}

\tadGeneradores
\tadOperacion{crearConjEstNat}{conj(nat)}{conj(EstNat)}{}

\tadOtrasOperaciones
\tadOperacion{\#}{conj(EstNat)}{nat}{}

\tadAxiomas[\paratodo{conj(nat)}{c}, \paratodo{nat}{n}]
\tadAlinearAxiomas{dameUno($c$) $\in$ $c$-----------}

\tadAxioma{$n \in$ crearConjEstNat($c$)}{($n \in c$)}

\tadAxioma{\#(crearConjEstNat($c$))}{\#($c$) }

\end{tad}
