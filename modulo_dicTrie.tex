\subsection{Interfaz}

%%Parámetros formales
  \subsubsection{Par\'ametros formales}
   \parbox{1.7cm}{\textbf{g\'eneros}} string, $\alpha$\\

  \textbf{se explica con}: \tadNombre{Diccionario(string, $\alpha$)}, \tadNombre{Iterador Unidireccional}.

  \textbf{g\'eneros}: \TipoVariable{diccString($\alpha$), itDicc(diccString)}. %%###revisar

%%Operaciones básicas
  \subsubsection{Operaciones b\'asicas de Diccionario String($\alpha$)}
%%crearDicc
  \InterfazFuncion{CrearDicc}{}{diccString($\alpha$)}
  {$res \igobs vacio$}%
  [O$(1)$]
  [Crea un diccionario vac\'io.]\\\\
%%definir
  \InterfazFuncion{Definir}{\Inout{d}{diccString($\alpha$)}, \In{c}{string}, \In{s}{$\alpha$}}{}
  [$d \igobs d_0 \wedge \neg def?(d,c)$]
  {$d \igobs definir(d_0,c,s)$}%
  [O$(longitud(c))$]
  [Define la clave c con el significado s en el diccionario d.]\\\\
%%definido?  
  \InterfazFuncion{Definido?}{\In{d}{diccString($\alpha$)}, \In{c}{string}}{bool}
  {$res \igobs def?(c,d)$}%
  [O$(longitud(c))$]
  [Devuelve true si y solo si c est\'a definido como clave en el diccionario.]\\\\
%%significado  
  \InterfazFuncion{Significado}{\In{d}{diccString($\alpha$)}, \In{c}{string}}{$\alpha$}
  [$def?(c,d)$]
  {$res \igobs obtener(c,d)$}%
  [O$(longitud(c))$]
  [Devuelve el significado con clave c.]
  [No se devuelve una copia del $\alpha$ en res, se devuelve una referencia a la original.]\\\\

 \subsubsection{Operaciones b\'asicas del iterador de claves de Diccionario String($\alpha$)}
  \InterfazFuncion{CrearIt}{\In{d}{diccString($\alpha$)}}{itClaves($string$)}
  {res \igobs crearIt(d.claves) }
  [O$(1)$]
  [Crea y devuelve un iterador de claves Diccionario String.]\\\\

  \InterfazFuncion{HayMas?}{\In{d}{itClaves($string$)}}{$bool$}
  {res \igobs hayMas?($it$)}%
  [O$(longitud(c))$] %%##revisar
  [Informa si hay m\'as elementos por iterar.]\\\\

  \InterfazFuncion{Actual}{\In{d}{itClaves($string$)}}{$string$}
  {res \igobs actual($it$)}
  [O$(longitud(c))$]%%##revisar
  [Devuelve la clave de la posici\'on actual.]\\\\

  \InterfazFuncion{Avanzar}{\Inout{it}{itClaves($string$)}}{itClaves($\alpha$)}
  [hayMas?($it$) $\land$ $it = it_{0}$] %%##revisar
  {res \igobs avanzar($it_{0}$)}
  [O$(longitud(c))$]%%##revisar
  [Avanza a la pr\'oxima clave.]\\\\


\subsection{Representacion}
  
  \subsubsection{Representaci\'on del Diccionario String($\alpha$)}
%%Estructura
  \begin{Estructura}{diccString$(\alpha)$}[estrDic]
    \begin{Tupla}[estrDic]
      \tupItem{raiz}{puntero(nodo)}
      \tupItem{claves}{lista\_enlazada($string$)}%%
    \end{Tupla}
\end{Estructura}

  \begin{Estructura}{Nodo}[estrNodo]
    \begin{Tupla}[estrNodo]
      \tupItem{valor}{puntero($\alpha$)}
      \tupItem{hijos}{arreglo\_estatico[256](puntero(nodo))}
    \end{Tupla}
\end{Estructura}

%%Rep 

\renewcommand{\labelenumi}{(\Roman{enumi})}
 \begin{enumerate}
 	\item Existe un \'unico camino entre cada nodo y el nodo raiz (es decir, no hay ciclos).
 	\item Todos los nodos hojas, es decir, todos los que tienen su arreglo hijos con todas sus posiciones en NULL, tienen que tener un valor distinto de NULL.
 	\item Raiz es distinto de NULL
 	\item En claves est\'a el camino que se recorre desde la raiz hasta cada nodo hoja.
  \end{enumerate}

\Rep[estrDic][e]{\\
 	\begin{minipage}[t]{\linewidth-\parindent-1.3cm}
  	{raiz != NULL \yluego \, noHayCiclos(e) $\land$ todasLasHojasTienenValor(e) $\land$\\ hayHojas(e) $\Rightarrow$ |e.claves|> 0 $\land$ \\($\forall$ c $\in$ caminosANodos(e))($\exists$ i \{0..|e.claves|\}) e.claves[i] = c}
  	\end{minipage}\vspace{3mm}
  	 }\mbox{}

 \Abs[estrDicc]{dicc(string,$\alpha$)}[e]{$d$}{($\forall$ c:string)(definido?($c,d$)) = ($\exists$ n: nodo)(n $\in$ todasLasHojas($e$)) n.valor != NULL \\ $\land$ ($\exists$ i \{0..|e.claves|\}) e.claves[i] = c $\yluego$ significado($c,d$) = leer($e.clave$).valor}


 \subsubsection{Operaciones auxiliares del invatriante de Representaci\'on}

  \tadOperacion{noHayCiclos}{puntero(nodo)}{bool}{}
  \tadAxioma{noHayCiclos($n,p$)}{($\exists$ n:nat)(($\forall$ c: string)(|s| = n $\Rightarrow$ leer($p,s$) = NULL))}
  \tadOperacion{leer}{puntero(nodo), string}{bool}{}
  \tadAxioma{leer($p,s$)}{\IF vacia?($s$) THEN p $\rightarrow$ valor ELSE {\IF p $\rightarrow$ hijos[prim(s)] = NULL THEN NULL ELSE leer(p $\rightarrow$ hijos[prim(s)], fin(s)) FI} FI}
  \tadOperacion{todosNull}{arreglo(puntero(nodo))}{bool}{}
  \tadAxioma{todosNull($a$)}{auxTodosNull($a, 0$)}
  \tadOperacion{auxTodosNull}{arreglo(puntero(nodo)), nat}{bool}{}
  \tadAxioma{auxTodosNull($a, i$)}{\IF i < |a| THEN a[i] == NULL $\land$ auxTodosNull($a, i+1$) ELSE a[i].valor == NULL FI}
  \tadOperacion{esHoja}{puntero(nodo)}{bool}{}
  \tadAxioma{esHoja($p$)}{\IF p == NULL THEN false ELSE todosNull(p.hijos) FI}
  \tadOperacion{todasLasHojas}{puntero(nodo), nat}{conj(nodo)}{}
  \tadAxioma{todasLasHojas($p, n$)}{\IF p == NULL THEN false ELSE {\IF esHoja($p$) THEN Ag(*p, vacio) ELSE auxTodasLasHojas((*p).hijos, 256) FI} FI}

  \tadOperacion{auxTodasLasHojas}{arreglo(puntero(nodo)), nat}{conj(nodo)}{}
  \tadAxioma{auxTodasLasHojas($a, n$)}{hojasDeHijos($a,n,0$)}

  \tadOperacion{hojasDeHijos}{arreglo(puntero(nodo)), nat, nat}{conj(nodo)}{}
  \tadAxioma{hojasDeHijos($a, n, i$)}{\IF i = n THEN $\emptyset$ ELSE todasLasHojas(a[i]) $\cup$ hojasDeHijos($a, n, (i+1)$) FI}

  \tadOperacion{todasLasHojasTienenValor}{puntero(nodo)}{bool}{}
  \tadAxioma{todasLasHojasTienenValor($p$)}{auxTodasLasHojasTienenValor(todasLasHojas($p, 256$))}

  \tadOperacion{auxTodasLasHojasTienenValor}{arreglo(puntero(nodo))}{bool}{}
  \tadAxioma{auxTodasLasHojasTienenValor($a$)}{\IF |a| = 0 THEN true ELSE dameUno(a).valor != NULL $\land$ auxTodasLasHojasTienenValor(sinUno(a)) FI}

  \subsubsection{Representaci\'on del iterador de Claves del Diccionario String($\alpha$)}

    \begin{Estructura}{itClaves($string$)}[puntero(nodo)]
    \end{Estructura}

    Su Rep y Abs son los de itSecu($\alpha$) definido en el apunte de iteradores..

  \subsection{Algoritmos}
\subsubsection{Algoritmos de Diccionario String}

\textsc{iCrearDicc}() $\rightarrow$ \textbf{res} = diccString($\alpha$)
\begin{lstlisting}[mathescape]
 n $\leftarrow$ nodo
 n $\leftarrow$ crearNodo()
 raiz $\leftarrow$ *n
\end{lstlisting}
\textbf{Complejidad}\\

\textsc{iCrearNodo}() $\rightarrow$ \textbf{res} = nodo
\begin{lstlisting}[mathescape]
 d : arreglo\_estatico[256]
 i $\leftarrow$ 0
 while (i < 256)
 	d[i] $\leftarrow$ NULL
 endWhile
 hijos $\leftarrow$ d
 valor $\leftarrow$ NULL
\end{lstlisting}
\textbf{Complejidad}\\

\textsc{iDefinir}(\textbf{in/out} diccString($\alpha$): d, \textbf{in} string: c, \textbf{in} alfa: s)
\begin{lstlisting}[mathescape]
 i $\leftarrow$ 0
 p $\leftarrow$ d.raiz
 while (i < (longitud(s)))
 	if (p.hijos[ord(s[i])] == NULL)
		n: nodo $\leftarrow$ crearNodo()
		p.hijos[ord(s[i])] $\leftarrow$ *n
	endIf
 p $\leftarrow$ p.hijos[ord(s[i])]
 i++
 endWhile
 p.valor $\leftarrow$ a
 agregarAdelante(hijos, c)
\end{lstlisting}
\textbf{Complejidad}\\

\textsc{iSignificado}(\textbf{in} diccString($\alpha$): d, \textbf{in} string: c) $\rightarrow$ \textbf{res} = $\alpha$
\begin{lstlisting}[mathescape]
 i $\leftarrow$ 0
 p $\leftarrow$ d.raiz
 while (i < (longitud(s)))
	p $\leftarrow$ p.hijos[ord(s[i])]
 i++
 endWhile
 return p.valor
\end{lstlisting}
\textbf{Complejidad}\\

\textsc{iDefinido?}(\textbf{in} diccString($\alpha$): d, \textbf{in} string: c) $\rightarrow$ \textbf{res} = bool
\begin{lstlisting}[mathescape]
 i $\leftarrow$ 0
 p $\leftarrow$ d.raiz
 while (i < (longitud(s)))
 	if (p.hijos[ord(s[i])] != NULL)
		p $\leftarrow$ p.hijos[ord(s[i])]
		i++
	else
		return false
	endIf
 endWhile
 return p.valor != NULL
\end{lstlisting}
\textbf{Complejidad}\\

\textsc{iClaves}(\textbf{in} diccString($\alpha$): d) $\rightarrow$ \textbf{res} = lista\_enlazada(string)
\begin{lstlisting}[mathescape]
return itClaves(d)
\end{lstlisting}
\textbf{Complejidad}\\

\subsubsection{Algoritmos del iterador de claves del Diccionario String}

Utiliza los mismos algoritmos que itSecu($\alpha$) definido en el apunte de iteradores.

