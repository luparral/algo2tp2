\subsection{Interfaz}

%%Parámetros formales
  \subsubsection{Par\'ametros formales}

  \textbf{se explica con}: \tadNombre{Diccionario(string, $\alpha$)}, \tadNombre{Iterador Unidireccional}.

  \textbf{g\'eneros}: \TipoVariable{diccString($\alpha$), itClaves(diccString)}. %%###revisar

%%Operaciones básicas
  \subsubsection{Operaciones b\'asicas de Diccionario String($\alpha$)}
%%crearDicc
  \InterfazFuncion{CrearDicc}{}{diccString($\alpha$)}
  {$res \igobs vacio$}%
  [O$(1)$]
  [Crea un diccionario vac\'io.]\\\\
%%definir
  \InterfazFuncion{Definir}{\Inout{d}{diccString($\alpha$)}, \In{c}{string}, \In{s}{$\alpha$}}{}
  [$d \igobs d_0 \wedge \neg def?(d,c)$]
  {$d \igobs definir(d_0,c,s)$}%
  [O$(longitud(c))$]
  [Define la clave c con el significado s en el diccionario d.]\\\\
%%definido?  
  \InterfazFuncion{Definido?}{\In{d}{diccString($\alpha$)}, \In{c}{string}}{bool}
  {$res \igobs def?(c,d)$}%
  [O$(longitud(c))$]
  [Devuelve true si y solo si c est\'a definido como clave en el diccionario.]\\\\
%%significado  
  \InterfazFuncion{Significado}{\In{d}{diccString($\alpha$)}, \In{c}{string}}{$\alpha$}
  [$def?(c,d)$]
  {$res \igobs obtener(c,d)$}%
  [O$(longitud(c))$]
  [Devuelve el significado con clave c.]
  [No se devuelve una copia del $\alpha$ en res, se devuelve una referencia a la original.]\\\\

 \subsubsection{Operaciones b\'asicas del iterador de claves de Diccionario String($\alpha$)}
  \InterfazFuncion{CrearIt}{\In{d}{diccString($\alpha$)}}{itClaves($string$)}
  {res \igobs crearIt(d.claves) }
  [O$(1)$]
  [Crea y devuelve un iterador de claves de Diccionario String.]\\\\

  \InterfazFuncion{HayMas?}{\In{d}{itClaves($string$)}}{$bool$}
  {res \igobs hayMas?($it$)}%
  [O$(longitud(c))$] %%##revisar
  [Informa si hay m\'as elementos por iterar.]\\\\

  \InterfazFuncion{Actual}{\In{d}{itClaves($string$)}}{$string$}
  {res \igobs actual($it$)}
  [O$(longitud(c))$]%%##revisar
  [Devuelve la clave de la posici\'on actual.]\\\\

  \InterfazFuncion{Avanzar}{\Inout{it}{itClaves($string$)}}{itClaves($\alpha$)}
  [hayMas?($it$) $\land$ $it = it_{0}$] %%##revisar
  {res \igobs avanzar($it_{0}$)}
  [O$(longitud(c))$]%%##revisar
  [Avanza a la pr\'oxima clave.]\\\\


\subsection{Representaci\'on}
  
  \subsubsection{Representaci\'on del Diccionario String($\alpha$)}
%%Estructura
  \begin{Estructura}{diccString$(\alpha)$}[estrDic]
    \begin{Tupla}[estrDic]
      \tupItem{raiz}{puntero(nodo)}
      \tupItem{claves}{lista($string$)}%%
    \end{Tupla}
\end{Estructura}

  \begin{Estructura}{Nodo}[estrNodo]
    \begin{Tupla}[estrNodo]
      \tupItem{valor}{puntero($\alpha$)}
      \tupItem{hijos}{arreglo\_est\'atico[256](puntero(nodo))}
    \end{Tupla}
\end{Estructura}

%%Rep 

\renewcommand{\labelenumi}{(\Roman{enumi})}
 \begin{enumerate}
 	\item Existe un \'unico camino entre cada nodo y el nodo ra\'iz (no hay ciclos).
 	\item Todos los nodos hojas, es decir, todos los que tienen su arreglo hijos con todas sus posiciones en NULL, tienen que tener un valor distinto de NULL.
 	\item Ra\'iz es distinto de NULL
 	\item En claves est\'a el camino que se recorre desde la ra\'z hasta cada nodo hoja.
  \end{enumerate}

\Rep[estrDic][e]{\\
 	\begin{minipage}[t]{\linewidth-\parindent-1.3cm}
  	{ra\'iz != NULL \yluego \, noHayCiclos(e) $\land$ todasLasHojasTienenValor(e) $\land$\\ hayHojas(e) $\Rightarrow$ |e.claves|> 0 $\land$ \\($\forall$ c $\in$ caminosANodos(e))($\exists$ i \{0..|e.claves|\}) e.claves[i] = c}
  	\end{minipage}\vspace{3mm}
  	 }\mbox{}



 \subsubsection{Operaciones auxiliares del invatriante de Representaci\'on}

  \tadOperacion{noHayCiclos}{puntero(nodo)}{bool}{}
  \tadAxioma{noHayCiclos($n,p$)}{($\exists$ n:nat)(($\forall$ c: string)(|s| = n $\Rightarrow$ leer($p,s$) = NULL))}
  \tadOperacion{leer}{puntero(nodo), string}{bool}{}
  \tadAxioma{leer($p,s$)}{\IF vacia?($s$) THEN p $\rightarrow$ valor ELSE {\IF p $\rightarrow$ hijos[prim(s)] = NULL THEN NULL ELSE leer(p $\rightarrow$ hijos[prim(s)], fin(s)) FI} FI}
  \tadOperacion{todosNull}{arreglo(puntero(nodo))}{bool}{}
  \tadAxioma{todosNull($a$)}{auxTodosNull($a, 0$)}
  \tadOperacion{auxTodosNull}{arreglo(puntero(nodo)), nat}{bool}{}
  \tadAxioma{auxTodosNull($a, i$)}{\IF i < |a| THEN a[i] == NULL $\land$ auxTodosNull($a, i+1$) ELSE a[i].valor == NULL FI}
  \tadOperacion{esHoja}{puntero(nodo)}{bool}{}
  \tadAxioma{esHoja($p$)}{\IF p == NULL THEN false ELSE todosNull(p.hijos) FI}
  \tadOperacion{todasLasHojas}{puntero(nodo), nat}{conj(nodo)}{}
  \tadAxioma{todasLasHojas($p, n$)}{\IF p == NULL THEN false ELSE {\IF esHoja($p$) THEN Ag(*p, vacio) ELSE auxTodasLasHojas((*p).hijos, 256) FI} FI}

  \tadOperacion{auxTodasLasHojas}{arreglo(puntero(nodo)), nat}{conj(nodo)}{}
  \tadAxioma{auxTodasLasHojas($a, n$)}{hojasDeHijos($a,n,0$)}

  \tadOperacion{hojasDeHijos}{arreglo(puntero(nodo)), nat, nat}{conj(nodo)}{}
  \tadAxioma{hojasDeHijos($a, n, i$)}{\IF i = n THEN $\emptyset$ ELSE todasLasHojas(a[i]) $\cup$ hojasDeHijos($a, n, (i+1)$) FI}

  \tadOperacion{todasLasHojasTienenValor}{puntero(nodo)}{bool}{}
  \tadAxioma{todasLasHojasTienenValor($p$)}{auxTodasLasHojasTienenValor(todasLasHojas($p, 256$))}

  \tadOperacion{auxTodasLasHojasTienenValor}{arreglo(puntero(nodo))}{bool}{}
  \tadAxioma{auxTodasLasHojasTienenValor($a$)}{\IF |a| = 0 THEN true ELSE dameUno(a).valor != NULL $\land$ auxTodasLasHojasTienenValor(sinUno(a)) FI}

\subsubsection{Funci\'on de abstracci\'on}
 \Abs[estrDicc]{dicc(string,$\alpha$)}[e]{$d$}{($\forall$ c:string)(definido?($c,d$)) = ($\exists$ n: nodo)(n $\in$ todasLasHojas($e$)) n.valor != NULL \\ $\land$ ($\exists$ i:nat)(i $\in$ \{0..|e.claves|\}) $\Rightarrow$ e.claves[i] = c $\yluego$ significado($c,d$) = leer($e.clave$).valor}

  \subsubsection{Representaci\'on del iterador de Claves del Diccionario String($\alpha$)}



    \begin{Estructura}{itClaves($string$)}[puntero(nodo)]
    \end{Estructura}

    Su Rep y Abs son los de itSecu($\alpha$) definido en el apunte de iteradores.

  \subsection{Algoritmos}
\subsubsection{Algoritmos de Diccionario String}

\textsc{iCrearDicc}() $\rightarrow$ \textbf{res} = diccString($\alpha$)
\begin{lstlisting}[mathescape]
 n $\leftarrow$ nodo $\hfill$ O(1)
 n $\leftarrow$ crearNodo() 					O(1)
 raiz $\leftarrow$ *n 							O(1)
\end{lstlisting}
\textbf{Complejidad:} 3*O(1)

\textsc{iCrearNodo}() $\rightarrow$ \textbf{res} = nodo
\begin{lstlisting}[mathescape]
 d : arreglo\_estatico[256] 					O(1)
 i $\leftarrow$ 0 								O(1)
 while (i < 256) 								256*
 	d[i] $\leftarrow$ NULL 						O(1)
 endWhile
 hijos $\leftarrow$ d 							O(1)
 valor $\leftarrow$ NULL 						O(1)
\end{lstlisting}
\textbf{Complejidad:}2*O(1) + 256*O(1) + 2*O(1)

\textsc{iDefinir}(\textbf{in/out} diccString($\alpha$): d, \textbf{in} string: c, \textbf{in} alfa: s)
\begin{lstlisting}[mathescape]
 i $\leftarrow$ 0 								O(1)
 p $\leftarrow$ d.raiz 							O(1)
 while (i < (longitud(s))) 						|s|*
 	if (p.hijos[ord(s[i])] == NULL) 			O(1)
		n: nodo $\leftarrow$ crearNodo() 		O(1)
		p.hijos[ord(s[i])] $\leftarrow$ *n 		O(1)
	endIf
 p $\leftarrow$ p.hijos[ord(s[i])] 				O(1)
 i++ 											O(1)
 endWhile
 p.valor $\leftarrow$ a 						O(1)
 agregarAdelante(hijos, c) 						O(|s|)
\end{lstlisting}
\textbf{Complejidad:} 2*O(1) + |s|*5*O(1) + O(1) + O(|s|) = O(|s|)

\textsc{iSignificado}(\textbf{in} diccString($\alpha$): d, \textbf{in} string: c) $\rightarrow$ \textbf{res} = $\alpha$
\begin{lstlisting}[mathescape]
 i $\leftarrow$ 0 								O(1)
 p $\leftarrow$ d.raiz 							O(1)
 while (i < (longitud(s))) 						|s|*
	p $\leftarrow$ p.hijos[ord(s[i])] 			O(1)
 i++ 											O(1)
 endWhile
 return p.valor 								O(1)
\end{lstlisting}
\textbf{Complejidad:} 2*O(1) + |s|*2*O(1) + O(1) = O(|s|)

\textsc{iDefinido?}(\textbf{in} diccString($\alpha$): d, \textbf{in} string: c) $\rightarrow$ \textbf{res} = bool
\begin{lstlisting}[mathescape]
 i $\leftarrow$ 0 								O(1)
 p $\leftarrow$ d.raiz 							O(1)
 while (i < (longitud(s))) 						|s|*
 	if (p.hijos[ord(s[i])] != NULL) 			O(1)
		p $\leftarrow$ p.hijos[ord(s[i])] 		O(1)
		i++ O(1)
	else
		return false 							O(1)
	endIf
 endWhile
 return p.valor != NULL 						O(1)
\end{lstlisting}
\textbf{Complejidad:} 2*O(1) + |s|*3*O(1) + O(1) = O(|s|)

\textsc{iClaves}(\textbf{in} diccString($\alpha$): d) $\rightarrow$ \textbf{res} = lista\_enlazada(string)
\begin{lstlisting}[mathescape]
return itClaves(d)								O(1)
\end{lstlisting}
\textbf{Complejidad:} O(1)

\subsubsection{Algoritmos del iterador de claves del Diccionario String}

Utiliza los mismos algoritmos que itSecu($\alpha$) definido en el apunte de iteradores.


\subsection{Servicios Usados}
\begin{center}
\begin{tabular*}{2.75\textwidth}{c |c | c }
\textbf{M\'odulo} & \textbf{Operaci\'on} & \textbf{Complejidad Requerida}\\
arreglo\_est\'atico & AgregarElemento & O(1)\\
arreglo\_est\'atico & $\bullet$[$\bullet$] & O(1)\\
lista & AgregarAdelante & O(copy($\alpha$))\\
lista & $\bullet$[$\bullet$] & O(1)\\
\end{tabular*}
\end{center}

