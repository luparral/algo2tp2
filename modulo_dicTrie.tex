\subsection{Interfaz}
%%###no tenemos no parametros formales?

  %%\InterfazFuncion{AgregarAdelante}{\Inout{l}{lista($\alpha$)}, \In{a}{$\alpha$}}{itLista($\alpha$}

%%Parámetros formales
  \subsubsection{Par\'ametros formales}
   \parbox{1.7cm}{\textbf{g\'eneros}} string, $\alpha$\\
    %%\parbox[t]{1.7cm}{\textbf{funci\'on}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
     %%\InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
     %%{$res \igobs a$}
     %%[$\Theta(copy(a))$]
     %%[funci\'on de copia de $\alpha$ s]
    %%}

  \textbf{se explica con}: \tadNombre{Diccionario}.

  \textbf{g\'eneros}: \TipoVariable{diccString($\alpha$)}.

%%Operaciones básicas
  \subsubsection{Operaciones b\'asicas de Diccionario String($\alpha$)}
%%crearDicc
  \InterfazFuncion{CrearDicc}{()}{diccString($\alpha$)}
  {$res \igobs vacio$}%
  [$\Theta(1)$]
  [Crea un diccionario vac\'io.]\\\\
%%definir
  \InterfazFuncion{Definir}{\Inout{d}{diccString($\alpha$)}, \In{c}{string}, \In{s}{$\alpha$}}{}
  [$d \igobs d_0 \wedge \neg definido?(d,c)$]
  {$d \igobs definir(d_0,c,s)$}%
  [$\Theta(longitud(c))$]
  [Define la clave c con el significado s en el diccionario d.]\\\\
%%definido?  
  \InterfazFuncion{Definido?}{\In{d}{diccString($\alpha$)}, \In{c}{string}}{bool}
  {$res \igobs def?(c,d)$}%
  [$\Theta(longitud(c))$]
  [Devuelve true si y solo si c est\'a definido como clave en el diccionario.]\\\\
%%significado  
  \InterfazFuncion{Significado}{\In{d}{diccString($\alpha$)}, \In{c}{string}}{$\alpha$}
  [$def?(c,d)$]
  {$res \igobs obtener(c,d)$}%
  [$\Theta(longitud(c))$]
  [Devuelve el significado con clave c.]
  [No se devuelve una copia del $\alpha$ en res, se devuelve una referencia a la original.]\\\\
%%todosLosSignificados  

\subsection{Representacion}
  
  \subsubsection{Representaci\'on del Diccionario String($\alpha$)}
%%Estructura
  \begin{Estructura}{diccString$(\alpha)$}[estrDic]
    \begin{Tupla}[estrDic]
      \tupItem{raiz}{puntero(nodo)}%%
    \end{Tupla}
\end{Estructura}

  \begin{Estructura}{Nodo}[estrNodo]
    \begin{Tupla}[estrNodo]
      \tupItem{valor}{puntero($\alpha$)}
      \tupItem{hijos}{arreglo(puntero(nodo))}%%
    \end{Tupla}
\end{Estructura}

%%Rep 

\renewcommand{\labelenumi}{(\Roman{enumi})}
 \begin{enumerate}
 	\item Existe un \'unico camino entre cada nodo y el nodo raiz (es decir, no hay ciclos).
 	\item Todos los nodos hojas, es decir, todos los que tienen su arreglo hijos con todas sus posiciones en NULL, tienen que tener un valor distinto de NULL.
 	\item Raiz es distinto de NULL
 	\item El arreglo hijos de cualquier nodo tiene 256 posiciones.
  \end{enumerate}

\Rep[estrDic][e]{\\
 	\begin{minipage}[t]{\linewidth-\parindent-1.3cm}
  	{raiz != NULL \yluego \, noHayCiclos(e) $\land$ todasLasHojasTienenValor(e) $\land$ nodosConCantHijosValidos(e)} 
  	\end{minipage}\vspace{3mm}
  	 }\mbox{}

  \tadOperacion{damePromesas}{itTrie??????, estr, cliente}{conj(promesa)}{}
  \tadAxioma{damePromesas($it, e, c$)}{{\IF hayMas?($it$) THEN $\bold{if}$ buscarCliente(obtener(actual($it$))).$promCompra \neq$ NULL $\bold{then}$ \\\phantom{---}\{buscarCliente(obtener(actual($it$))).$promCompra \neq$ NULL\} $\cup$ $\bold{fi}$\\ $\bold{if}$ buscarCliente(obtener(actual($it$))).$promVenta \neq$ NULL $\bold{then}$ \\\phantom{---}\{buscarCliente(obtener(actual($it$))).$promVenta \neq$ NULL\} $\cup$ $\bold{fi}$\\ damePromesas(avanzar($it$), $e$, $c$) ELSE vacio FI}}

\subsection{Algoritmos}


\begin{algorithm}
\caption{iCrearDicc}
\label{() -> res = diccString}
\begin{algorithmic}
%\begin{comment}
\State $n : nodo$
\State $n \gets crearNodo()$
\State $raiz \gets *n$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{iCrearNodo()}
\label{() -> res = nodo}
\begin{algorithmic}
%\begin{comment}
\State $d : arreglo\_estatico[256]$
\State $i \gets 0$
\While {$i < 256$}
\State $d[i] \gets NULL$
\EndWhile
\State $hijos \gets d$
\State $valor \gets NULL$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{iDefinir}
\label{inout d: diccString(alfa), in c: string, in s: alfa}
\begin{algorithmic}
%\begin{comment}
\State $i \gets 0$
\State $p \gets d.raiz$
\While {$i < (longitud(s))$}
\If {$p.hijos[ord(s[i])] == NULL$}
\State $n: nodo \gets crearNodo()$
\State $p.hijos[ord(s[i])] \gets *n$
\EndIf
\State $p \gets p.hijos[ord(s[i])]$
\State $i++$
\EndWhile
\State $p.valor \gets a$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{iSignificado}
\label{in d: diccString(alfa), in c: string -> res = alfa}
\begin{algorithmic}
%\begin{comment}
\State $i \gets 0$
\State $p \gets d.raiz$
\While {$i < (longitud(s))$}
\State $p \gets p.hijos[ord(s[i])]$
\State $i++$
\EndWhile\\
\Return $p.valor$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{iDefinido?}
\label{in d: diccString, in c: string -> res = bool}
\begin{algorithmic}
\State $i \gets 0$
\State $p \gets d.raiz$
\While {$i < (longitud(s))$}
\If {$p.hijos[ord(s[i])] != NULL$}
\State $p \gets p.hijos[ord(s[i])]$
\State $i++$
\Else \\{$\Return false$}
\EndIf
\EndWhile\\
\Return $p.valor != NULL$
\end{algorithmic}
\end{algorithm}


\end{document}